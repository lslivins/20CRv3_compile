--- GFS_Initialize_ESMFMod.f.orig	2016-07-01 12:20:26.000000000 -0400
+++ GFS_Initialize_ESMFMod.f	2016-07-01 12:24:58.000000000 -0400
@@ -359,22 +359,27 @@
       endif
 !
 !     if (.not. adiab) then
-      if (ntoz <= 0) then      ! Diagnostic ozone
-        rewind (kozc)
-        read (kozc,end=101) latsozc, levozc, timeozc, blatc4
-  101   if (levozc < 10 .or. levozc > 100) then
-          rewind (kozc)
-          levozc  = 17
-          latsozc = 18
-          blatc   = -85.0
-        else
-          blatc   = blatc4
-        endif
-        latsozp   = 2
-        levozp    = 1
-        timeoz    = 1
-        pl_coeff  = 0
-      else                       ! Prognostic Ozone
+!     if (ntoz <= 0) then      ! Diagnostic ozone
+!       rewind (kozc)
+!       read (kozc,end=101) latsozc, levozc, timeozc, blatc4
+! 101   if (levozc < 10 .or. levozc > 100) then
+!         rewind (kozc)
+          !levozc  = 17
+          !levozc = 17 ! global_o3clim.txt
+          !latsozc = 18
+          !blatc = -85.0
+          levozc  = 28 ! CMIP5 data
+          latsozc = 37
+          blatc   = -90.0
+          timeozc = 12
+!       else
+!         blatc   = blatc4
+!       endif
+!       latsozp   = 2
+!       levozp    = 1
+!       timeoz    = 1
+!       pl_coeff  = 0
+!     else                       ! Prognostic Ozone
         rewind (kozpl)
         read (kozpl) pl_coeff, latsozp, levozp, timeoz
         allocate (pl_lat(latsozp), pl_pres(levozp),pl_time(timeoz+1))
@@ -385,9 +390,9 @@
         pl_pres(:) = pl_pres4(:)
         pl_lat(:)  = pl_lat4(:)
         pl_time(:) = pl_time4(:)
-        latsozc = 2
-        blatc   = 0.0
-      endif
+        !latsozc = 2
+        !blatc   = 0.0
+!     endif
       dphiozc = -(blatc+blatc)/(latsozc-1)
 !
       if (me .eq. 0) then
--- Makefile.orig	2016-07-01 12:28:23.000000000 -0400
+++ Makefile	2016-07-01 12:28:44.000000000 -0400
@@ -22,6 +22,7 @@
 FFLAG_SER = $(OPTS_SER) $(DOUBLEFLAG)  $(DEBUG) 
 
 LDR	 = $(LDRM)
+ESMFLIB  = $(ESMFLIBM)
 LDFLAGS =  $(LDFLAGSM)
 LIBS =  $(LIBSM)
 
@@ -66,6 +67,8 @@
 
 OBJ_MOD	= machine.o                 \
 	  num_parthds.o             \
+	  sigio_module.o		\
+	  sigio_r_module.o		\
 	  iounitdef.o               \
 	  physpara.o                \
 	  physcons.o                \
@@ -184,7 +187,8 @@
 	triseori.o                        \
 	uveodz.o                          \
 	ysminv.o                          \
-	fftpack.o                         
+	fftpack.o                         \
+ 	byteswap.o                        \
 
 OBJS_PORT	=           \
 	noblas.o
@@ -285,8 +289,6 @@
 model-mpi-port: $(OBJ_MOD) $(OBJS_CC) $(OBJS0) $(OBJS) $(OBJS_PHY) $(OBJS_RAD) $(OBJS_IO) $(OBJS_PORT)
 	$(LDR) -o $(EXEC) $(OBJ_MOD) $(OBJS_CC) $(OBJS0) $(OBJS) $(OBJS_PHY) $(OBJS_RAD) $(OBJS_IO) $(OBJS_PORT) $(LIBS) $(LDFLAGS)
 
-install:
-	cp -p $(EXEC) ../../exec/.
 clean:
 	rm -f $(OBJ_MOD) $(OBJS0) $(OBJS) $(OBJS_RAD) $(OBJS_PHY) $(OBJS_IO) $(OBJS_CC) *.mod
 
@@ -329,6 +331,9 @@
 get_prs.o:	get_prs.f
 		$(F77) $(FFLAGM) -c get_prs.f
 
+byteswap.o:	byteswap.c
+	 	$(FCC) -c $(CFLAGS) byteswap.c
+
 filtr1eo.o:	filtr1eo.f 
 		$(F77) $(FFLAG_SER)   -c filtr1eo.f 
 
@@ -698,3 +703,9 @@
 
 mygather.o:		mygather.c
 		$(CC) -c mygather.c
+
+sigio_module.o:	sigio_module.f
+		$(F77) $(FFLAGSI) -c sigio_module.f
+
+sigio_r_module.o:	sigio_r_module.f
+		$(F77) $(FFLAGSI) -c sigio_r_module.f
--- byteswap.c.orig	2016-07-01 12:29:13.000000000 -0400
+++ byteswap.c	2016-07-01 12:29:33.000000000 -0400
@@ -0,0 +1,32 @@
+/* Include the C library file for definition/control */
+/* Things that might be changed for new systems are there. */
+/* This source file should not (need to) be edited, merely recompiled */
+#include "clib.h"
+
+#ifdef LINUX
+  void byteswap_
+         (char *data, int *nbyte, int *nnum) {
+#endif
+#ifdef IBM4
+  void byteswap
+         (char *data, int *nbyte, int *nnum) {
+#endif
+#ifdef IBM8
+  void byteswap
+         (char *data, long long int *nbyte, long long int *nnum) {
+#endif
+  int  i, j;
+  char swap[256];
+  int  nb=*nbyte;
+  int  nn=*nnum;
+
+
+  for (j=0; j<nn; j++) {
+
+    for (i=0; i<nb; i++) swap[i] = data[j*nb+i];
+
+    for (i=0; i<nb; i++) data[j*nb+i] = swap[nb-i-1];
+
+  }
+
+}
--- gbphys.f.orig	2016-07-01 12:11:28.000000000 -0400
+++ gbphys.f	2016-07-01 12:15:31.000000000 -0400
@@ -25,6 +25,7 @@
 !           redrag,hybedmf,dspheat,cal_pre,                             !
 !           mom4ice,trans_trac,nst_fcst,fscav,                          !
 !           thermodyn_id, sfcpress_id, gen_coord_hybrid, adjtrc,nnp,    !
+!           sppt_wt,                                                    !
 !       input/outputs:                                                  !
 !           hice,fice,tisfc,tsea,tprcp,cv,cvb,cvt,                      !
 !           srflag,snwdph,weasd,sncovr,zorl,canopy,                     !
@@ -92,6 +93,7 @@
 !      jul  2013  - r. sun     added pdf cloud                          !
 !      jul  2013  - j. han     added reduced drag coef. over sea        !
 !      jan  2014  - h.juang and f.yang added energy conversion from gwd !
+!      aug  2015  - p.pegion   add sppt weight for precipitation
 !                                                                       !
 !                                                                       !
 !  ====================  defination of variables  ====================  !
@@ -217,6 +219,7 @@
 !     gen_coord_hybrid - logical for henry's gen coord             1    !
 !     adjtrc       - real, dynamics adjustments to tracers       ntrac  !
 !     nnp      - integer, physics substep number                   1    !
+!     sppt_wt      - real, stochastic physics weights              im   !
 !                                                                       !
 !  input/outputs:                                                       !
 !     hice     - real, sea-ice thickness                           im   !
@@ -369,6 +372,7 @@
      &      redrag,hybedmf,dspheat,cal_pre,                             &
      &      mom4ice,trans_trac,nst_fcst,fscav,                          &
      &      thermodyn_id, sfcpress_id, gen_coord_hybrid, adjtrc,nnp,    &
+     &      sppt_wt,                                                    &
 !  ---  input/outputs:
      &      hice,fice,tisfc,tsea,tprcp,cv,cvb,cvt,                      &
      &      srflag,snwdph,weasd,sncovr,zorl,canopy,                     &
@@ -449,7 +453,7 @@
      &      sinlat, coslat, pgr,    dpshc,  xlon,   xlat,               &
      &      slope,  shdmin, shdmax, snoalb, tg3,    slmsk,  vfrac,      &
      &      vtype,  stype,  uustar, oro,    coszen, sfcnsw, sfcdsw,     &
-     &      sfcdlw, tsflw,  sfalb,  sfcemis, oro_uf
+     &      sfcdlw, tsflw,  sfalb,  sfcemis, oro_uf,sppt_wt
 
       real(kind=kind_phys), dimension(ix,levs),       intent(in) ::     &
      &      ugrs, vgrs, tgrs, vvel, prsl, prslk, phil, swh,swhc,hlw,hlwc
@@ -1714,6 +1718,10 @@
         endif
       endif   ! end if_not_ras
 !
+!     added by PJP, precipitation is scaled by sppt
+      do i = 1, im
+         rain1(i) = rain1(i) * sppt_wt(i)
+      enddo
       do i = 1, im
         rainc(i) = frain * rain1(i)
       enddo
@@ -1969,6 +1977,11 @@
             enddo
           endif 
 
+!     added by PJP, precipitation is scaled by sppt
+          do i = 1, im
+            rain1(i) = rain1(i) * sppt_wt(i)
+          enddo
+
           do i = 1, im
             raincs(i) = frain * rain1(i)
           enddo
@@ -2142,6 +2155,10 @@
       endif   ! end if_ncld
 
 !     if (lprnt) print *,' rain1=',rain1(ipr),' rainc=',rainc(ipr)
+!     added by PJP, precipitation is scaled by sppt
+      do i = 1, im
+         rain1(i) = rain1(i) * sppt_wt(i)
+      enddo
 
       do i = 1, im
         rainl(i) = frain    * rain1(i)
--- gloopb.f.orig	2016-07-01 12:04:10.000000000 -0400
+++ gloopb.f	2016-07-01 12:11:21.000000000 -0400
@@ -146,6 +146,7 @@
 !! sppt additional variables
       real (kind=kind_phys) ugrd0(ngptc,levs),vgrd0(ngptc,levs)
       real (kind=kind_phys) gr0(ngptc,levs,ntrac),gt0(ngptc,levs)
+      real (kind=kind_phys)  sppt_wts2(ngptc)
 !   variables for stochastic physics
 !-----------------------------------
       real (kind=kind_phys),dimension(ngptc,levs)        ::
@@ -838,7 +839,7 @@
 !$omp+private(det_mf_v)
 !$omp+private(njeff,item,jtem,ktem,i,j,k,kss,n,nn,nnr)
 !$omp+private(uphys,vphys,tphys,qphys)
-!$omp+private(sppt_wts)
+!$omp+private(sppt_wts,sppt_wts2)
 !$omp+private(dtdt)
 
 !!!$omp+private(temlon,temlat,lprnt,ipt)
@@ -1119,6 +1120,14 @@
 
 !     for tracer fixer
 
+          if (stochphys .and. sppt(1) > 0) then ! stoch. perturbed physics tend.
+            do i=1,njeff
+               sppt_wts2(i)=sppt_wt(lon+i-1,lan,4)
+            enddo
+          else
+            sppt_wts2(:)=1.0
+          endif
+
           do ntr=1,ntrac
             if (fixtrc(ntr) .and. .not. iauforcing) then
               do k=1,levs
@@ -1159,6 +1168,7 @@
      &      redrag,hybedmf,dspheat,cal_pre,                             &
      &      mom4ice,trans_trac,nst_fcst,fscav,                          &
      &      thermodyn_id, sfcpress_id, gen_coord_hybrid,  adjtrc, nn,   &
+     &      sppt_wts2(1:njeff),                                         &
 !  ---  input/outputs:
      &      sfc_fld%hice  (lon,lan),    sfc_fld%fice  (lon,lan),        &
      &      sfc_fld%tisfc (lon,lan),    sfc_fld%tsea  (lon,lan),        &
--- gloopr.f.orig	2016-07-01 12:20:32.000000000 -0400
+++ gloopr.f	2016-07-01 12:24:58.000000000 -0400
@@ -948,7 +948,9 @@
      &       sinlat_v,coslat_v,solhr,jdat,solcon,                       &
      &       cv(lon,lan),cvt(lon,lan),cvb(lon,lan),                     &
      &       f_ice,f_rain,r_rime,flgmin_v,                              &
-     &       icsdsw,icsdlw,ntcw-1,ncld,ntoz-1,ntrac-1,nfxr,             &
+!    &       icsdsw,icsdlw,ntcw-1,ncld,ntoz-1,ntrac-1,nfxr,             &
+! use ozone climo in radiation.
+     &       icsdsw,icsdlw,ntcw-1,ncld,0,ntrac-1,nfxr,                  &
      &       dtlw,dtsw,lsswr,lslwr,lssav,                               &
      &       ngptc,njeff,levr, me, lprnt,ipt,kdt,deltaq,sup,cnvw,cnvc,  &
 !  ---  outputs:
--- grrad.f.orig	2016-07-01 12:20:41.000000000 -0400
+++ grrad.f	2016-07-01 12:39:10.000000000 -0400
@@ -208,6 +208,7 @@
 
 !  ---  constant values
       real (kind=kind_phys) :: qmin, qme5, qme6, epsq
+      real (kind=kind_phys) :: sumcoslat,sumo3,sumo3pred
 !     parameter (qmin=1.0e-10, qme5=1.0e-5,  qme6=1.0e-6,  epsq=1.0e-12)
       parameter (qmin=1.0e-10, qme5=1.0e-7,  qme6=1.0e-7,  epsq=1.0e-12)
 !     parameter (qmin=1.0e-10, qme5=1.0e-20, qme6=1.0e-20, epsq=1.0e-12)
@@ -968,7 +969,7 @@
       real (kind=kind_phys), dimension(im,lm+1+ltp):: plvl, tlvl
 
       real (kind=kind_phys), dimension(im,lm+ltp)  :: plyr, tlyr, qlyr, &
-     &       olyr, rhly, qstl, vvel, clw, prslk1, tem2da, tem2db, tvly
+     &olyrpred,olyr,rhly, qstl, vvel, clw, prslk1, tem2da, tem2db, tvly
 
       real (kind=kind_phys), dimension(im) :: tsfa, cvt1, cvb1, tem1d,  &
      &       sfcemis, tsfg, tskn
@@ -1160,26 +1161,41 @@
 
 !  --- ...  get layer ozone mass mixing ratio
 
-      if (ntoz > 0) then            ! interactive ozone generation
+      !if (ntoz > 0) then            ! interactive ozone generation
 
         do k = 1, lmk
           do i = 1, im
-            olyr(i,k) = max( qmin, tracer1(i,k,ntoz) )
+            olyrpred(i,k) = max( qmin, tracer1(i,k,ntoz) )
           enddo
         enddo
 
-      else                          ! climatological ozone
+      !else                          ! climatological ozone
 
 !     print *,' in grrad : calling getozn'
         call getozn                                                     &
 !  ---  inputs:
-     &     ( prslk1,xlat,                                               &
+     &     ( me, prslk1,xlat,                                           &
      &       im, lmk,                                                   &
 !  ---  outputs:
      &       olyr                                                       &
      &     )
 
-      endif                            ! end_if_ntoz
+      !endif                            ! end_if_ntoz
+
+!       do k = 1, lmk
+!         sumo3pred = 0.
+!         sumo3 = 0.
+!         sumcoslat = 0.
+!         do i = 1, im
+!           sumo3pred = sumo3pred + olyrpred(i,k)
+!           sumo3 = sumo3 + olyr(i,k)
+!           sumcoslat = sumcoslat + coslat(im)
+!         enddo
+!         print *,'me,k,meanoz',
+!    &    me,k,sumo3pred/sumcoslat,sumo3/sumcoslat
+!       enddo
+
+      if (ntoz .ne. 0) olyr=olyrpred
 
 !  --- ...  compute cosin of zenith angle
 
--- makefile.sh.orig	2016-07-01 12:28:31.000000000 -0400
+++ makefile.sh	2016-07-01 12:28:38.000000000 -0400
@@ -1,184 +1,54 @@
 #!/bin/ksh
-set -x
-
-mac=$(hostname | cut -c1-1)
-mac2=$(hostname | cut -c1-2)
-
-#export debug=YES                      # uncomment this line if you want debug option
-#export CLEAN=NO                       # uncomment this if you don't want to clean before compiling
-export USE_MKL=YES
-export ICS_VERSION=14.0.1
- 
-#---------------------------------------------------------
-if [ $mac = t -o $mac = g ] ; then # For WCOSS
-#---------------------------------------------------------
- machine=wcoss
- ptmp="/ptmpp1/$LOGNAME"
- export NWPRODLIB=/nwprod/lib
-
- export SIGIO_VER=v2.0.1
- export SIGIO_DIR=$NWPRODLIB/sigio/$SIGIO_VER
- export SIGIO_LIB4=sigio_${SIGIO_VER}_4
- export SIGIO_INC4=${SIGIO_DIR}/incmod/$SIGIO_LIB4
-
- export W3NCO_VER=v2.0.6
- export W3NCO_DIR=$NWPRODLIB/w3nco/$W3NCO_VER
- export W3NCO_LIBd=w3nco_${W3NCO_VER}_d
-
- export W3EMC_VER=v2.0.5
- export W3EMC_DIR=$NWPRODLIB/w3emc/$W3EMC_VER
- export W3EMC_LIBd=w3emc_${W3EMC_VER}_d
- export W3EMC_INCd=$NWPRODLIB/w3emc/$W3EMC_VER/incmod/w3emc_${W3EMC_VER}_d
-
- export SP_VER=v2.0.2
- export SP_DIR=$NWPRODLIB/sp/$SP_VER
- export SP_LIBd=sp_${SP_VER}_d
-
- export BACIO_VER=v2.0.1
-#export BACIO_DIR=$NWPRODLIB/bacio/$BACIO_VER
-#export BACIO_LIB4=bacio_${BACIO_VER}_4
- export BACIO_DIR=/usrx/local/nceplibs
- export BACIO_LIB4=bacio_v2.0.1p_4
-
- export NEMSIO_VER=v2.2.1
- export NEMSIO_DIR=$NWPRODLIB/nemsio/$NEMSIO_VER
- export NEMSIO_LIB=nemsio_${NEMSIO_VER}
-
- export ESMF_LIB=/usrx/local/esmf-3.1.0rp5/lib/libO/Linux.intel.64.intelmpi.default
- export ESMF_MOD=/usrx/local/esmf-3.1.0rp5/mod/modO/Linux.intel.64.intelmpi.default
-
- if [ $USE_MKL = YES ] ; then
-   export ALIGN="-align array32byte"              # For bit reproducibility on wcoss
-   . /usrx/local/Modules/3.2.10/init/ksh          # To enable module unload and load
-   module unload ics
-   export ICS_VERSION=${ICS_VERSION:-14.0.1}
-   module load ics/$ICS_VERSION
-  export PRECISE=source
-  #export PRECISE=precise
- fi
-
- export FINC=-I$ESMF_MOD
- export FINCM="-I$SIGIO_INC4 -I$W3EMC_INCd "
- export LIBSM="-L$BACIO_DIR -l$BACIO_LIB4 -L$SIGIO_DIR -l$SIGIO_LIB4 -L$NEMSIO_DIR -l$NEMSIO_LIB -L$SP_DIR -l$SP_LIBd \
-               -L$W3EMC_DIR -l$W3EMC_LIBd -L$W3NCO_DIR -l$W3NCO_LIBd -lrt -lstdc++ -L$ESMF_LIB -lesmf"
-
-#---------------------------------------------------------
-elif [ $mac = z -o $mac = h -o $mac = f ] ; then # For ZEUS
-#---------------------------------------------------------
- machine=zeus
- ptmp=/scratch2/portfolios/NCEPDEV/ptmp/$LOGNAME
- export LIBDIR=/contrib/nceplibs/nwprod/lib
- export NCEPLIB=/contrib/nceplibs/dev/lib
- export ESMF_LIB=/apps/esmf/3.1.0rp5/intel/mpt/lib/libO/Linux.intel.64.mpi.default        
- export ESMF_MOD=/apps/esmf/3.1.0rp5/intel/mpt/mod/modO/Linux.intel.64.mpi.default        
-
- export W3LIB=w3nco_d
- export FINC=-I$ESMF_MOD
- export FINCM="-I$NCEPLIB/incmod/sigio_v2.0.1_beta -I$LIBDIR/incmod/$W3LIB"
- export LIBSM="-L$NCEPLIB -lsigio_v2.0.1_beta -L$LIBDIR -lbacio_4 -lnemsio -lsp_d -l$W3LIB -lrt -lstdc++ -L$ESMF_LIB -lesmf"
-#---------------------------------------------------------
-fi
-#---------------------------------------------------------
-
-export ALIGN=${ALIGN:-""}
-#
-#  WARNING!!! The default endianness is local to the machine.
-#   If your initial conditions are bigendian and want to compile on littleendian
-#   machine, you must set NATIVE_ENDIAN=NO
-#
-NATIVE_ENDIAN=NO
-#
+export LIBDIR=/lustre/f1/unswept/Jeffrey.S.Whitaker/nwprod/lib
+export ESMFDIR=/lustre/f1/unswept/Jeffrey.S.Whitaker/nwprod/lib
+#export ESMFDIR=/sw/xt6/esmf/esmf_3_1_0rp2/lib/libO/Linux.pgi.64.mpiuni.default/
+NATIVE_ENDIAN=${NATIVE_ENDIAN:-NO}
 sorc_dir=$(pwd)
 exec_dir=$(pwd)
 mkdir -p $exec_dir
 
-#make_dir=$ptmp/branch/sorc/$(basename $sorc_dir)
-#mkdir -p $make_dir ; cd $make_dir || exit 8
-#cp -rp ${sorc_dir}/* .
+export LIBDIR=${LIBDIR:-../../lib}
+#rm *.o
+#rm *.mod
 
 if [ $NATIVE_ENDIAN = YES ] ; then
  cp $sorc_dir/sigio_r_module_native.f sigio_r_module.f
  cp $sorc_dir/bafrio_native.f         bafrio.f
 fi
-export PRECISE=${PRECISE:-precise}
 
-#
-#-------------------------------------------------------------------
-#-------------------------------------------------------------------
-if [ $machine = zeus -o $machine = wcoss ] ; then
- export CFLAGS="-DLINUX"
- export ARCHM=
- export PGSZM=
- export FRRM=-FR
+#export EXECM=global_fcst_predoz
+export EXECM=global_fcst_cmip5
 
- export debug=${debug:-NO}
- if [ $debug = YES ] ; then
-   export OPTSB="-g -O0 -check all -ftrapuv -convert big_endian $ALIGN -fp-stack-check -fstack-protector -heap-arrays -recursive $ALIGN"  
-   export OPTSBT="$OPTSB -traceback"
-   export EXECM=$exec_dir/global_fcst_dbg
- else
-   if [ $machine = zeus ]; then
-    export OPTSB="-g -O3 -convert big_endian $ALIGN -fp-model $PRECISE "  
-    export OPTSBX="-g -O3 -convert big_endian $ALIGN -fp-model $PRECISE "  
-   else
-    export OPTSB="-g -O3 -convert big_endian $ALIGN -fp-model $PRECISE -xAVX "  
-    export OPTSBX="-g -O3 -convert big_endian $ALIGN -fp-model $PRECISE -xAVX "  
-   fi
-   export OPTSBT=$OPTSB
-   export OPTSBTX=$OPTSBX
-   export EXECM=$exec_dir/global_fcst
- fi
-
- export OPTSIOM="$OPTSBT -r8 -openmp"
- export OPTSIOX="$OPTSBTX -r8 -openmp"
- export OPTSM="$OPTSBT -r8 -openmp"
- export OPTS_SERM="$OPTSBT -r8 $ARCHM"
- export OPTS90M="$OPTSBT   -r8 "
- export OPTS90AM="$OPTSBT  -r8 "
- export LDFLAGSM=$PGSZM
-
- #----------------------------
- if [ $machine = wcoss ] ; then
-   export F77M=mpiifort
-   export F90M=mpiifort
-   export F77B=$F77M
-   export FCC=mpcc
-   export LDRM=mpiifort
-   if [ $USE_MKL = YES ] ; then
-      module unload ics
-      module load ics/$ICS_VERSION
-      export LDFLAGSM="$PGSZM -openmp -lmkl_intel_lp64 -lmkl_core -lmkl_sequential -lpthread -lm"
-   else
-      export LDFLAGSM="$PGSZM -openmp "
-   fi
- #----------------------------
- elif [ $machine = zeus ] ; then
-   export F77M="ifort -openmp"  #-recursive"
-   export F90M="ifort -openmp"  #-recursive"
-   export F77B="ifort "         #-recursive" #-openmp"  #-recursive"
-   export F90B="ifort "         #-recursive" #-openmp"  #-recursive"
-   export LDRM="ifort -lmpi"
-   export FCC=cc
-   if [ $USE_MKL = YES ] ; then
-      export LDFLAGSM="$PGSZM -openmp -mkl"
-   else
-      export LDFLAGSM="$PGSZM -openmp "
-   fi
- fi
- #----------------------------
-else
- echo 'machine not supported at this time'
- exit
-fi
-#-------------------------------------------------------------------
-#-------------------------------------------------------------------
-
-echo $F77M
-make -f Makefile clean
-if [ $USE_MKL = YES ] ; then
-  make -f Makefile
-else
-  make -f Makefile model-mpi-port
-fi
-make -f Makefile install
-make -f Makefile clean
+export W3LIB=w3lib-2.0_d
+export CFLAGS="-DLINUX"
+export FINCM=-I$LIBDIR/incmod/$W3LIB
+export ARCHM=
+export PGSZM=
+export FRRM=-FR
+export FXXM=
+#export OPTSB="-g -O3 -convert big_endian -fp-model strict -heap-arrays -xHost"  #raghu.reddy:prod
+export OPTSB="-O3 -xHost -fp-model precise -convert big_endian"
+# -ftrapuv (trap unitialized vars) - causes model to crash in gfidi_hyb
+# where unitialized values are used. Check to see if -zero produces
+# identical results?
+# -warn all catches a lot of interface errors .
+export OPTSBT="$OPTSB -implicitnone -traceback"
+export OPTSM="$OPTSBT -r8"       # -openmp"    # raghu.reddy
+export OPTSIOM="$OPTSBT -r8 "
+export OPTSIOX="$OPTSBT -r8 "
+export OPTS_SERM="$OPTSBT -r8 $ARCHM"
+export OPTS90M="$OPTSBT   -r8 "
+export OPTS90AM="$OPTSBT  -r8 "
+export LDFLAGSM=$PGSZM
+export F77M="ftn -openmp"  #-recursive"
+export F90M="ftn -openmp"  #-recursive"
+export F77B="ftn "         #-recursive" #-openmp"  #-recursive"
+export F90B="ftn "         #-recursive" #-openmp"  #-recursive"
+export LDRM="ftn"
+export FCC=cc
+export LDFLAGSM="$PGSZM -openmp -mkl"            #raghu.reddy
+export FINC=-I$ESMFDIR/incmod/esmf_3_1_0rp5      #raghu.reddy
+#export FINC=-I/sw/xt6/esmf/esmf_3_1_0rp2/mod/modO/Linux.pgi.64.mpiuni.default/
+export LIBSM="-L$LIBDIR  -lbacio_4 -lnemsio -lsp_d -l$W3LIB -lrt -L$ESMFDIR -lesmf_3_1_0rp5 -lstdc++ -mkl"
+#export LIBSM="-L$LIBDIR  -lbacio_4 -lnemsio -lsp_d -l$W3LIB -lrt -L$ESMFDIR -lesmf -lstdc++ -mkl"
+make -f Makefile
--- num_parthds.f.orig	2016-07-01 12:41:17.000000000 -0400
+++ num_parthds.f	2016-07-01 12:41:30.000000000 -0400
@@ -1,11 +1,11 @@
       integer function num_parthds()
       use omp_lib
-!!$omp parallel
-!     num_parthds = omp_get_num_threads()
-      num_parthds = 8
+!$omp parallel
+      num_parthds = omp_get_num_threads()
+!     num_parthds = 8
 !     num_parthds = 6
 !     num_parthds = 4
-!!$omp end parallel
+!$omp end parallel
       return
       end
 
--- rad_initialize.f.orig	2016-07-01 12:21:14.000000000 -0400
+++ rad_initialize.f	2016-07-01 12:24:58.000000000 -0400
@@ -131,7 +131,7 @@
 
       ictmflg= ictm                     ! data ic time/date control flag
       ico2flg= ico2                     ! co2 data source control flag
-      ioznflg= ntoz                     ! ozone data source control flag
+      ioznflg= 0                        ! ozone data source control flag
 
       if ( ictm==0 .or. ictm==-2 ) then
         iaerflg = mod(iaer, 100)        ! no volcanic aerosols for clim hindcast
--- radiation_aerosols.f.orig	2016-07-01 12:45:33.000000000 -0400
+++ radiation_aerosols.f	2016-07-01 12:45:48.000000000 -0400
@@ -219,7 +219,7 @@
 ! --------------------------------------------------------------------- !
 
 !  ---  parameter constants:
-      integer, parameter :: minvyr = 1850    ! lower lim (year) data available
+      integer, parameter :: minvyr = 1810    ! lower lim (year) data available
       integer, parameter :: maxvyr = 1999    ! upper lim (year) data available
 
 !  ---  monthly, 45-deg lat-zone aerosols data set in subroutine 'aer_init'
--- radiation_gases.f.orig	2016-07-01 11:18:15.000000000 -0400
+++ radiation_gases.f	2016-07-01 12:27:09.000000000 -0400
@@ -293,6 +293,23 @@
    20         format(6x,10f6.2)
             enddo
           enddo
+        else if ( loz == 28 ) then       ! for the CMIP5 ozone from NCAS.
+          if ( me == 0 ) then
+             print *,'reading CMIP5 ozone data'
+          end if
+          do k = 1, loz
+            read (nio3clm,15) pstr4(k)
+          enddo
+          do imo = 1, 12
+            do j = 1, jmr
+              read (nio3clm,17) imond(imo), ilat(j,imo),                &
+     &                          (o3clim4(j,k,imo),k=1,loz)
+              if (me==0 .and. imo==12 .and. j==jmr)                     &
+     &        write (6,17) imond(imo), ilat(j,imo),                     &
+     &                          (o3clim4(j,k,imo),k=1,loz)
+   17         format(i2,i4,31f6.2)
+            enddo
+          enddo
         else                      ! for newer ozone climatology
           read (nio3clm)
           do k = 1, loz
@@ -323,6 +340,7 @@
           print *,'   found ozone data for levels pstr=',               &
      &            (pstr(k),k=1,loz)
 !         print *,' o3=',(o3r(15,k,1),k=1,loz)
+          print *,' o3=',(o3r(jmr,k,12)/1.655e-6,k=1,loz)
         endif
 
         do k = 1, loz
@@ -1000,7 +1018,7 @@
 !...................................
 
 !  ---  inputs:
-     &     ( prslk,xlat,                                                &
+     &     ( me,prslk,xlat,                                             &
      &       imax, lm,                                                  &
 !  ---  outputs:
      &       o3mmr                                                      &
@@ -1033,7 +1051,7 @@
       implicit none
 
 !  ---  inputs:
-      integer,  intent(in) :: imax, lm
+      integer,  intent(in) :: imax, lm, me
 
       real (kind=kind_phys), intent(in) :: prslk(:,:), xlat(:)
 
@@ -1068,6 +1086,8 @@
           j2   = jmr
           tem1 = 1.0
         endif
+!       if (me == 0)
+!    &  print *,'dglat,blte,elte,j1,j2,tem1',deglat,blte,elte,j1,j2,tem1
 
         tem2 = 1.0 - tem1
         do j = 1, loz
--- sfc_sice.f.orig	2016-07-01 12:41:44.000000000 -0400
+++ sfc_sice.f	2016-07-01 12:42:30.000000000 -0400
@@ -151,11 +151,11 @@
 !
 !  --- ...  set minimum ice concentration required
 
-      if (mom4ice) then
+      !if (mom4ice) then
          cimin = 0.15          ! mom4ice and mask
-      else
-         cimin = 0.50          ! gfs only
-      endif
+      !else
+      !   cimin = 0.50          ! gfs only
+      !endif
 
 !  --- ...  set flag for sea-ice
 
--- sigio_module.f.orig	2016-07-01 12:29:20.000000000 -0400
+++ sigio_module.f	2016-07-01 12:29:39.000000000 -0400
@@ -0,0 +1,1820 @@
+!-------------------------------------------------------------------------------
+module sigio_module
+!$$$  Module Documentation Block
+!
+! Module:    sigio_module    API for global spectral sigma file I/O
+!   Prgmmr: iredell          Org: w/nx23     date: 1999-01-18
+!
+! Abstract: This module provides an Application Program Interface
+!   for performing I/O on the sigma restart file of the global spectral model.
+!   Functions include opening, reading, writing, and closing as well as
+!   allocating and deallocating data buffers used in the transfers.
+!   The I/O performed here is sequential.
+!   The transfers are limited to header records or data records.
+!   
+! Program History Log:
+!   1999-01-18  Mark Iredell
+!   2013-10-14  Fanglin Yang: Added dynamics restart fields (ixga etc)
+!                 and restructureed physics restart fields (ixgr etc).
+!
+! Public Variables:
+!   sigio_lhead1      Integer parameter length of first header record (=32)
+!   sigio_charkind    Integer parameter kind or length of passed characters (=8)
+!   sigio_intkind     Integer parameter kind or length of passed integers (=4)
+!   sigio_realkind    Integer parameter kind or length of passed reals (=4)
+!   sigio_dblekind    Integer parameter kind or length of passed longreals (=8)
+!   sigio_realfill    Real(sigio_realkind) parameter fill value (=-9999.)
+!   sigio_dblefill    Real(sigio_dblekind) parameter fill value (=-9999.)
+!
+! Public Defined Types:
+!   sigio_head        Sigma file header information
+!     clabsig           Character(sigio_lhead1) ON85 label
+!                       (obsolescent)
+!     fhour             Real(sigio_realkind) forecast hour
+!     idate             Integer(sigio_intkind)(4) initial date
+!                       (hour, month, day, 4-digit year)
+!     si                Real(sigio_realkind)(101) sigma interfaces
+!                       (obsolescent)
+!     sl                Real(sigio_realkind)(100) sigma levels
+!                       (obsolescent)
+!     ak                Real(sigio_realkind)(101) hybrid interface a
+!                       (obsolescent)
+!     bk                Real(sigio_realkind)(101) hybrid interface b
+!                       (obsolescent)
+!     jcap              Integer(sigio_intkind) spectral truncation
+!     levs              Integer(sigio_intkind) number of levels
+!     itrun             Integer(sigio_intkind) truncation flag
+!                       (=1 for triangular)
+!     iorder            Integer(sigio_intkind) coefficient order flag
+!                       (=2 for ibm order)
+!     irealf            Integer(sigio_intkind) floating point flag
+!                       (=1 for 4-byte ieee, =2 for 8-byte ieee)
+!     igen              Integer(sigio_intkind) model generating flag
+!     latf              Integer(sigio_intkind) latitudes in dynamics
+!                       (=(jcap+1)*3/2)
+!     lonf              Integer(sigio_intkind) longitudes in dynamics
+!                       (>=(jcap+1)*3 appropriate for fft)
+!     latb              Integer(sigio_intkind) latitudes in physics
+!     lonb              Integer(sigio_intkind) longitudes in physics
+!     latr              Integer(sigio_intkind) latitudes in radiation
+!     lonr              Integer(sigio_intkind) longitudes in radiation
+!     ntrac             Integer(sigio_intkind) number of tracers
+!     icen2             Integer(sigio_intkind) subcenter id
+!     iens              Integer(sigio_intkind)(2) ensemble ids
+!     idpp              Integer(sigio_intkind) processing id
+!     idsl              Integer(sigio_intkind) semi-lagrangian id
+!     idvc              Integer(sigio_intkind) vertical coordinate id
+!                       (=1 for sigma, =2 for ec-hybrid, =3 for ncep hybrid)
+!     idvm              Integer(sigio_intkind) mass variable id
+!     idvt              Integer(sigio_intkind) tracer variable id
+!     idrun             Integer(sigio_intkind) run id
+!     idusr             Integer(sigio_intkind) user-defined id
+!     pdryini           Real(sigio_realkind) global mean dry air pressure (kPa)
+!                       (obsolescent)
+!     ncldt             Integer(sigio_intkind) number of cloud types
+!     ixgr              Integer(sigio_intkind) extra fileds for physics.
+!                         ixgr=00000000  no extra fields                                      
+!                         ixgr=0000000a  zhao micro,    a=1: zhao1, two 3d, one 2d, and nxss=0            
+!                                                       a=2: zhao2, four 3d, three 2d, and nxss=0            
+!                                                       a=3: zhao2, four 3d, three 2d, and nxss=1            
+!                         ixgr=000000b0  ferrier micro, b=1: three 3d, one 2d, and nxss=0          
+!                                        ferrier micro, b=2: three 3d, one 2d, and nxss=1           
+!                         ixgr=00000c00  c=1, pdf cld, three 3d                      
+!     ixga              Integer(sigio_intkind) extra fileds for dynamics. 
+!                         ixga=00000000  no extra fields                                      
+!                         ixga=0000000a  zflxtvd micro,   ntrac 3d, zero 2d            
+!                         ixga=000000b0  (reserved for) joe-sela semi-lag gfs
+!     ivs               Integer(sigio_intkind) version number
+!     nvcoord           Integer(sigio_intkind) number of vcoord profiles
+!  The following variables should be allocated with sigio_alhead:
+!     vcoord            Real(sigio_realkind)((levs+1),nvcoord) vcoord profiles
+!     cfvars            Character(8)(5+ntrac) field variable names
+!  The following variables should not be modified by the user:
+!     nxgr              Integer(sigio_intkind) number of extra physics grid fields
+!     nxss              Integer(sigio_intkind) number of extra scalars
+!     nxga              Integer(sigio_intkind) number of extra dynamics grid fields
+!     nhead             Integer(sigio_intkind) number of header records
+!     ndata             Integer(sigio_intkind) number of data records
+!     lhead             Integer(sigio_intkind)(nhead) header record lengths
+!     ldata             Integer(sigio_intkind)(ndata) data record lengths
+!
+!   sigio_data        Sigma file data fields
+!     hs                Real(sigio_realkind)(:) pointer to spectral
+!                       coefficients of surface height in m
+!     ps                Real(sigio_realkind)(:) pointer to spectral
+!                       coefficients of log of surface pressure over 1 kPa
+!     t                 Real(sigio_realkind)(:,:) pointer to spectral
+!                       coefficients of virtual temperature by level in K
+!     d                 Real(sigio_realkind)(:,:) pointer to spectral
+!                       coefficients of divergence by level in 1/second
+!     z                 Real(sigio_realkind)(:,:) pointer to spectral
+!                       coefficients of vorticity by level in 1/second
+!     q                 Real(sigio_realkind)(:,:,:) pointer to spectral
+!                       coefficients of tracers by level and tracer number
+!                       in specific densities
+!     xgr               Real(sigio_realkind)(:,:,:) pointer to extra grid fields
+!                       by longitude, latitude and number of extra physics grid fields
+!     xss               Real(sigio_realkind)(:) pointer to scalar array
+!     xga               Real(sigio_realkind)(:,:,:) pointer to extra dynamics grid fields
+!                       by longitude, latitude and number of extra grid fields
+!                       
+!   sigio_dbta        Sigma file longreal data fields
+!     hs                Real(sigio_dblekind)(:) pointer to spectral
+!                       coefficients of surface height in m
+!     ps                Real(sigio_dblekind)(:) pointer to spectral
+!                       coefficients of log of surface pressure over 1 kPa
+!     t                 Real(sigio_dblekind)(:,:) pointer to spectral
+!                       coefficients of virtual temperature by level in K
+!     d                 Real(sigio_dblekind)(:,:) pointer to spectral
+!                       coefficients of divergence by level in 1/second
+!     z                 Real(sigio_dblekind)(:,:) pointer to spectral
+!                       coefficients of vorticity by level in 1/second
+!     q                 Real(sigio_dblekind)(:,:,:) pointer to spectral
+!                       coefficients of tracers by level and tracer number
+!                       in specific densities
+!     xgr               Real(sigio_dblekind)(:,:,:) pointer to extra physics grid fields
+!                       by longitude, latitude and number of extra grid fields
+!     xss               Real(sigio_dblekind)(:) pointer to scalar array
+!     xga               Real(sigio_dblekind)(:,:,:) pointer to extra dynamics grid fields
+!                       by longitude, latitude and number of extra grid fields
+!                       
+! Public Subprograms:
+!   sigio_sropen      Open sigma file for sequential reading
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_swopen      Open sigma file for sequential writing
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_sclose      Close sigma file for sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_srhead      Read header information with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) output header information
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_swhead      Write header information with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_alhead      Allocate head allocatables
+!     head              Type(sigio_head) input/output header information
+!     iret              Integer(sigio_intkind) output return code
+!     levs              Integer(sigio_intkind) optional number of levels
+!     nvcoord           Integer(sigio_intkind) optional number of vcoords
+!     ntrac             Integer(sigio_intkind) optional number of tracers
+!
+!   sigio_aldata      Allocate data fields
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdata      Deallocate data fields
+!     data              Type(sigio_data) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_srdata      Read data fields with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_swdata      Write data fields with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) input data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldbta      Allocate longreal data fields
+!     head              Type(sigio_head) input header information
+!     dbta              Type(sigio_dbta) output longreal data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdbta      Deallocate longreal data fields
+!     dbta              Type(sigio_dbta) output longreal data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_srdbta      Read longreal data fields with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbta              Type(sigio_dbta) output longreal data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_swdbta      Write longreal data fields with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbta              Type(sigio_dbta) input longreal data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_srohdc      Open, read header & data and close with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     head              Type(sigio_head) output header information
+!     data              Type(sigio_data) or type(sigio_dbta) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_swohdc      Open, write header & data and close with sequential I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) or type(sigio_dbta) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_modpr        Compute model pressures
+!     im                Integer(sigio_intkind) input number of points
+!     ix                Integer(sigio_intkind) input first dimension
+!     km                Integer(sigio_intkind) input number of levels
+!     nvcoord           Integer(sigio_intkind) input number of vertical coords
+!     idvc              Integer(sigio_intkind) input vertical coordinate id
+!                       (1 for sigma and 2 for hybrid)
+!     idsl              Integer(sigio_intkind) input type of sigma structure
+!                       (1 for phillips or 2 for mean)
+!     vcoord            Real(sigio_realkind)(km+1,nvcoord) input vertical coords
+!                       for idvc=1, nvcoord=1: sigma interface
+!                       for idvc=2, nvcoord=2: hybrid interface a and b
+!     iret              Integer(sigio_intkind) output return code
+!     ps                Real(sigio_realkind)(ix) input optional surface pressure (Pa)
+!     tv                Real(sigio_realkind)(ix,km) input optional virtual temperature (K)
+!     pd                Real(sigio_realkind)(ix,km) output optional delta pressure (Pa)
+!     pm                Real(sigio_realkind)(ix,km) output optional layer pressure (Pa)
+!
+!   sigio_modprd      Compute model pressures - double precision
+!     im                Integer(sigio_intkind) input number of points
+!     ix                Integer(sigio_intkind) input first dimension
+!     km                Integer(sigio_intkind) input number of levels
+!     nvcoord           Integer(sigio_intkind) input number of vertical coords
+!     idvc              Integer(sigio_intkind) input vertical coordinate id
+!                       (1 for sigma and 2 for hybrid)
+!     idsl              Integer(sigio_intkind) input type of sigma structure
+!                       (1 for phillips or 2 for mean)
+!     vcoord            Real(sigio_realkind)(km+1,nvcoord) input vertical coords
+!                       for idvc=1, nvcoord=1: sigma interface
+!                       for idvc=2, nvcoord=2: hybrid interface a and b
+!     iret              Integer(sigio_intkind) output return code
+!     ps                Real(sigio_dblekind)(ix) input optional surface pressure (Pa)
+!     tv                Real(sigio_dblekind)(ix,km) input optional virtual temperature (K)
+!     pd                Real(sigio_dblekind)(ix,km) output optional delta pressure (Pa)
+!     pm                Real(sigio_dblekind)(ix,km) output optional layer pressure (Pa)
+!
+!   sigio_adhead        Set private data in header
+!     head              Type(sigio_head) input/output header information
+!
+!   sigio_cnvpsv        Convert from model mass variable to pressure (Pa)
+!                       when cnflg > 0, or the opposite when cnflag <= 0.
+!                       Values of IDVM determines variable. 
+!     im                Integer(sigio_intkind) input number of points
+!     idvm              Integer(sigio_intkind) mass variable id
+!     ps                Real(sigio_realkind)(im) inout mass variable or ps (Pa)
+!     dp                Real(sigio_realkind)(im) output dp(out)/dp(in)
+!     cnflg             Integer(sigio_intkind) input conversion flag.
+!                       when >0, conversion is to surface pressure (Pa) and
+!                       when <= 0, the conversion is to model mass variable.
+!
+!   sigio_cnvtdv        Convert from Virtual Temperature (Tv) or Enthalpy (h)
+!                       to sensible Temperature (when cnflag > 0) and the opposite
+!                       when cnflag <= 0. Values of IDVM determines Tv or h
+!     im                Integer(sigio_intkind) input number of points
+!     ix                Integer(sigio_intkind) input first dimension
+!     km                Integer(sigio_intkind) input number of levels
+!     idvc              Integer(sigio_intkind) input vertical coordinate id
+!                       (1 for sigma, 2 for hybrid, and 3 for general hybrid)
+!     idvm              Integer(sigio_intkind) mass variable id
+!                       (32 for enthalpy)
+!     ntrac             Integer(sigio_intkind) input number of tracers
+!     iret              Integer(sigio_intkind) output return code
+!     t                 Real(sigio_realkind)(ix,km) input Tv, h or T
+!     q                 Real(sigio_realkind)(ix,km,ntrac) input tracers
+!     cpi               Real(sigio_realkind)(ntrac) input specific heat at constant
+!                       pressure for tracers
+!    cnflg              Integer(sigio_intkind) input conversion flag. when >0
+!                       conversion is to dry temperature from Tv or h and when
+!                       <= 0, the conversion is from dry temperature to Tv or h.
+!
+! Remarks:
+!   (1) The sigma file format follows:
+!       For ivs=198410:
+!         ON85 label (32 bytes)
+!         Header information record containing
+!           real forecast hour, initial date, sigma interfaces, sigma levels,
+!           padding to allow for 100 levels, and finally 44 identifier words
+!           containing JCAP, LEVS, NTRAC, IREALF, etc. (250 4-byte words)
+!           (word size in the remaining records depends on the value of IREALF)
+!         Orography (NC words, where NC=(JCAP+1)*(JCAP+2))
+!         Log surface pressure (NC words)
+!         Temperature (LEVS records of NC words)
+!         Divergence & Vorticity interleaved (2*LEVS records of NC words)
+!         Tracers (LEVS*NTRAC records of NC words)
+!         Extra grid fields (NXGR records of LONB*LATB words)
+!       For ivs=200509:
+!         Label containing
+!           'GFS ','SIG ',ivs,nhead,ndata,reserved(3) (8 4-byte words)
+!         Header records
+!           lhead(nhead),ldata(ndata) (nhead+ndata 4-byte words)
+!           fhour, idate(4), jcap, levs, itrun, iorder, irealf, igen,
+!             latf, lonf, latb, lonb, latr, lonr, ntrac, nvcoord, 
+!             icen2, iens(2), idpp, idsl, idvc, idvm, idvt, idrun, idusr,
+!             pdryini, ncldt, ixgr, ixga,reserved(17) (50 4-byte words)
+!           vcoord((levs+1)*nvcoord 4-byte words)
+!           cfvars(5+ntrac 8-byte character words)
+!         Data records (word size depends on irealf)
+!           orography (nc words, where nc=(jcap+1)*(jcap+2))
+!           log surface pressure (nc words)
+!           temperature (levs records of nc words)
+!           divergence (levs records of nc words)
+!           vorticity (levs records of nc words)
+!           tracers (levs*ntrac records of nc words)
+!           scalars (nxss words)
+!           extra physics grid fields (nxgr records of lonb*latb words)
+!           extra scalars (nxss words)
+!           extra dynamics grid fields (nxga records of lonf*latf words)
+!
+!   (2) Possible return codes:
+!          0   Successful call
+!         -1   Open or close I/O error
+!         -2   Header record I/O error (possible EOF)
+!         -3   Allocation or deallocation error
+!         -4   Data record I/O error
+!         -5   Insufficient data dimensions allocated
+!
+! Examples:
+!   (1) Read the entire sigma file 'sigf24' and
+!       print out the global mean temperature profile.
+!
+!     use sigio_module
+!     type(sigio_head):: head
+!     type(sigio_data):: data
+!     call sigio_srohdc(11,'sigf24',head,data,iret)
+!     print '(f8.2)',data%t(1,head%levs:1:-1)/sqrt(2.)
+!     end
+!
+! Attributes:
+!   Language: Fortran 90
+!
+!$$$
+  implicit none
+  private
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Public Variables
+  integer,parameter,public:: sigio_lhead1=32
+  integer,parameter,public:: sigio_intkind=4,sigio_realkind=4,sigio_dblekind=8
+  integer,parameter,public:: sigio_charkind=8
+  real(sigio_intkind),parameter,public:: sigio_intfill=-9999_sigio_intkind
+  real(sigio_realkind),parameter,public:: sigio_realfill=-9999._sigio_realkind
+  real(sigio_dblekind),parameter,public:: sigio_dblefill=-9999._sigio_dblekind
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Public Types
+  type,public:: sigio_head
+    character(sigio_lhead1):: clabsig=' '
+    real(sigio_realkind):: fhour=sigio_realfill
+    integer(sigio_intkind):: idate(4)=sigio_intfill
+    real(sigio_realkind):: si(101)=sigio_realfill
+    real(sigio_realkind):: sl(100)=sigio_realfill
+    real(sigio_realkind):: ak(101)=sigio_realfill
+    real(sigio_realkind):: bk(101)=sigio_realfill
+    integer(sigio_intkind):: jcap=sigio_intfill
+    integer(sigio_intkind):: levs=sigio_intfill
+    integer(sigio_intkind):: itrun=sigio_intfill
+    integer(sigio_intkind):: iorder=sigio_intfill
+    integer(sigio_intkind):: irealf=sigio_intfill
+    integer(sigio_intkind):: igen=sigio_intfill
+    integer(sigio_intkind):: latf=sigio_intfill
+    integer(sigio_intkind):: lonf=sigio_intfill
+    integer(sigio_intkind):: latb=sigio_intfill
+    integer(sigio_intkind):: lonb=sigio_intfill
+    integer(sigio_intkind):: latr=sigio_intfill
+    integer(sigio_intkind):: lonr=sigio_intfill
+    integer(sigio_intkind):: ntrac=sigio_intfill
+    integer(sigio_intkind):: icen2=sigio_intfill
+    integer(sigio_intkind):: iens(2)=sigio_intfill
+    integer(sigio_intkind):: idpp=sigio_intfill
+    integer(sigio_intkind):: idsl=sigio_intfill
+    integer(sigio_intkind):: idvc=sigio_intfill
+    integer(sigio_intkind):: idvm=sigio_intfill
+    integer(sigio_intkind):: idvt=sigio_intfill
+    integer(sigio_intkind):: idrun=sigio_intfill
+    integer(sigio_intkind):: idusr=sigio_intfill
+    real(sigio_realkind):: pdryini=sigio_realfill
+    integer(sigio_intkind):: ncldt=sigio_intfill
+    integer(sigio_intkind):: ixgr=sigio_intfill
+    integer(sigio_intkind):: ixga=sigio_intfill
+    integer(sigio_intkind):: ivs=sigio_intfill
+    integer(sigio_intkind):: nvcoord=sigio_intfill
+    real(sigio_realkind),allocatable:: vcoord(:,:)
+    character(sigio_charkind),allocatable:: cfvars(:)
+    integer(sigio_intkind):: nxgr=sigio_intfill
+    integer(sigio_intkind):: nxss=sigio_intfill
+    integer(sigio_intkind):: nxga=sigio_intfill
+    integer(sigio_intkind):: nhead=sigio_intfill
+    integer(sigio_intkind):: ndata=sigio_intfill
+    integer(sigio_intkind),allocatable:: lhead(:)
+    integer(sigio_intkind),allocatable:: ldata(:)
+    real(sigio_realkind), allocatable :: cpi(:), ri(:)
+!   real(sigio_realkind):: cpi(100)=sigio_realfill
+!   real(sigio_realkind):: ri(100)=sigio_realfill
+  end type
+  type,public:: sigio_data
+    real(sigio_realkind),pointer:: hs(:)=>null()
+    real(sigio_realkind),pointer:: ps(:)=>null()
+    real(sigio_realkind),pointer:: t(:,:)=>null()
+    real(sigio_realkind),pointer:: d(:,:)=>null()
+    real(sigio_realkind),pointer:: z(:,:)=>null()
+    real(sigio_realkind),pointer:: q(:,:,:)=>null()
+    real(sigio_realkind),pointer:: xgr(:,:,:)=>null()
+    real(sigio_realkind),pointer:: xss(:)=>null()
+    real(sigio_realkind),pointer:: xga(:,:,:)=>null()
+  end type
+  type,public:: sigio_dbta
+    real(sigio_dblekind),pointer:: hs(:)=>null()
+    real(sigio_dblekind),pointer:: ps(:)=>null()
+    real(sigio_dblekind),pointer:: t(:,:)=>null()
+    real(sigio_dblekind),pointer:: d(:,:)=>null()
+    real(sigio_dblekind),pointer:: z(:,:)=>null()
+    real(sigio_dblekind),pointer:: q(:,:,:)=>null()
+    real(sigio_dblekind),pointer:: xgr(:,:,:)=>null()
+    real(sigio_dblekind),pointer:: xss(:)=>null()
+    real(sigio_dblekind),pointer:: xga(:,:,:)=>null()
+  end type
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Public Subprograms
+  public sigio_sropen,sigio_swopen,sigio_sclose,sigio_srhead,sigio_swhead  
+  public sigio_alhead,sigio_aldata,sigio_axdata,sigio_srdata,sigio_swdata  
+  public sigio_aldbta,sigio_axdbta,sigio_srdbta,sigio_swdbta  
+  public sigio_srohdc,sigio_swohdc  
+! public sigio_modpr,sigio_cnvtdv,sigio_cnvpsv
+  public sigio_modpr,sigio_cnvtdv,sigio_cnvpsv
+  public sigio_modprd,sigio_cnvtdvd,sigio_cnvpsvd
+  interface sigio_srohdc
+    module procedure sigio_srohdca,sigio_srohdcb
+  end interface
+  interface sigio_swohdc
+    module procedure sigio_swohdca,sigio_swohdcb
+  end interface
+! interface sigio_modpr
+!   module procedure sigio_modprs, sigio_modprd
+! end interface
+! interface sigio_cnvtdv
+!   module procedure sigio_cnvtdvs, sigio_cnvtdvd
+! end interface
+! interface sigio_cnvps
+!   module procedure sigio_cnvpsvs, sigio_cnvpsvd
+! end interface
+  public sigio_adhead
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Private Variables
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Private Types
+  type sigio_head2
+    sequence
+    real(sigio_realkind):: fhour
+    integer(sigio_intkind):: idate(4)
+    real(sigio_realkind):: sisl(2*100+1)
+    real(sigio_realkind):: ext(44)
+  end type
+contains
+!-------------------------------------------------------------------------------
+  subroutine sigio_sropen(lu,cfname,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    integer(sigio_intkind),intent(out):: iret
+    integer ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    open(lu,file=cfname,form='unformatted',&
+         status='old',action='read',iostat=ios)
+    iret=ios
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_swopen(lu,cfname,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    integer(sigio_intkind),intent(out):: iret
+    integer ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    open(lu,file=cfname,form='unformatted',&
+         status='unknown',action='readwrite',iostat=ios)
+    iret=ios
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_sclose(lu,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    integer(sigio_intkind),intent(out):: iret
+    integer ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    close(lu,iostat=ios)
+    iret=ios
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_srhead(lu,head,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(inout):: head
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_head2):: head2
+    character(4):: cgfs,csig
+    integer(sigio_intkind):: nhead,ndata,nresv(3)
+    integer:: ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    iret=-2
+    rewind lu
+    read(lu,iostat=ios) head%clabsig
+    if(ios.ne.0) return
+    if(head%clabsig(1:8).eq.'GFS SIG ') then  ! modern sigma file
+      rewind lu
+      read(lu,iostat=ios) cgfs,csig,head%ivs,nhead,ndata,nresv
+      if(ios.ne.0) return
+      if(head%ivs.eq.200509) then
+        read(lu,iostat=ios)
+        if(ios.ne.0) return
+        read(lu,iostat=ios) head%fhour,head%idate,head%jcap,head%levs,&
+          head%itrun,head%iorder,head%irealf,head%igen,head%latf,head%lonf,&
+          head%latb,head%lonb,head%latr,head%lonr,head%ntrac,head%nvcoord,&
+          head%icen2,head%iens,head%idpp,head%idsl,head%idvc,head%idvm,&
+          head%idvt,head%idrun,head%idusr,head%pdryini,head%ncldt,&
+          head%ixgr, head%ixga
+        if(ios.ne.0) return
+        if(head%ixga==0) head%nxga=0
+        call sigio_alhead(head,iret)
+        read(lu,iostat=ios) head%vcoord
+        if(ios.ne.0) return
+        read(lu,iostat=ios) head%cfvars
+        if(ios.ne.0) return
+        if (mod(head%idvm/10,10) == 3)then
+          read(lu,iostat=ios) head%cpi
+          if(ios.ne.0) return
+          read(lu,iostat=ios) head%ri
+          if(ios.ne.0) return
+        endif
+        head%clabsig=' '
+        head%si=sigio_realfill
+        head%sl=sigio_realfill
+        head%ak=sigio_realfill
+        head%bk=sigio_realfill
+        if(head%levs.lt.100.and.(head%idvc.eq.2.or.&
+         (head%idvc.eq.3.and.all(head%vcoord(:,3).eq.0)))) then
+          head%ak(1:head%levs+1)=head%vcoord(1:head%levs+1,1)
+          head%bk(1:head%levs+1)=head%vcoord(1:head%levs+1,2)
+        endif
+!       head%pdryini=sigio_realfill
+      else
+        return
+      endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      read(lu,iostat=ios) head2%fhour,head2%idate,head2%sisl,head2%ext
+      if(ios.ne.0) return
+      head%fhour=head2%fhour
+      head%idate=head2%idate
+      head%jcap=head2%ext(1)
+      head%levs=head2%ext(2)
+      head%itrun=head2%ext(3)
+      head%iorder=head2%ext(4)
+      head%irealf=head2%ext(5)
+      head%igen=head2%ext(6)
+      head%lonf=head2%ext(7)
+      head%latf=head2%ext(8)
+      head%lonb=head2%ext(9)
+      head%latb=head2%ext(10)
+      head%lonr=head2%ext(11)
+      head%latr=head2%ext(12)
+      head%ntrac=max(head2%ext(13),1.)
+      head%icen2=head2%ext(14)
+      head%iens=head2%ext(15:16)
+      head%idpp=head2%ext(17)
+      head%idsl=head2%ext(18)
+      head%idvc=head2%ext(19)
+      head%idvm=head2%ext(20)
+      head%idvt=head2%ext(21)
+      head%idrun=head2%ext(22)
+      head%idusr=head2%ext(23)
+      head%pdryini=head2%ext(24)
+      head%ncldt=head2%ext(25)
+      head%ixgr=head2%ext(26)
+      head%ixga=head2%ext(27)
+      head%si=sigio_realfill
+      head%sl=sigio_realfill
+      head%ak=sigio_realfill
+      head%bk=sigio_realfill
+      if(head%idvc.eq.0.or.head%idvc.eq.1) then
+        head%si(1:head%levs+1)=head2%sisl(1:head%levs+1)
+        head%sl(1:head%levs)=head2%sisl(head%levs+2:2*head%levs+1)
+        head%nvcoord=1
+        call sigio_alhead(head,iret)
+        head%vcoord(1:head%levs+1,1)=head2%sisl(1:head%levs+1)
+      elseif(head%idvc.eq.2) then
+        head%ak(1:head%levs+1)=head2%sisl(1:head%levs+1)
+        head%bk(1:head%levs+1)=head2%sisl(head%levs+2:2*head%levs+2)
+        head%nvcoord=2
+        call sigio_alhead(head,iret)
+        head%vcoord(1:head%levs+1,1)=head2%sisl(1:head%levs+1)
+        head%vcoord(1:head%levs+1,2)=head2%sisl(head%levs+2:2*head%levs+2)
+      elseif(head%idvc.eq.3) then
+        head%nvcoord=2
+        call sigio_alhead(head,iret)
+        head%vcoord(1:head%levs+1,1)=head2%sisl(1:head%levs+1)
+        head%vcoord(1:head%levs+1,2)=head2%sisl(head%levs+2:2*head%levs+2)
+      endif
+      head%ivs=198410
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_adhead(head)
+    iret=0
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_swhead(lu,head,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(inout):: head
+    integer(sigio_intkind),intent(out):: iret
+    integer(sigio_intkind) lhead,ldata
+    type(sigio_head2):: head2
+    integer:: ios
+    integer i
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    iret=-2
+    call sigio_adhead(head)
+    rewind lu
+    if(head%ivs.ge.200509) then
+      write(lu,iostat=ios) 'GFS SIG ',head%ivs,head%nhead,head%ndata,0,0,0
+      if(ios.ne.0) return
+      write(lu,iostat=ios) head%lhead,head%ldata
+      if(ios.ne.0) return
+      write(lu,iostat=ios) head%fhour,head%idate,head%jcap,head%levs,&
+        head%itrun,head%iorder,head%irealf,head%igen,head%latf,head%lonf,&
+        head%latb,head%lonb,head%latr,head%lonr,head%ntrac,head%nvcoord,&
+        head%icen2,head%iens,head%idpp,head%idsl,head%idvc,head%idvm,&
+        head%idvt,head%idrun,head%idusr,head%pdryini,head%ncldt,&
+        head%ixgr,head%ixga, (0,i=1,17)
+      if(ios.ne.0) return
+      if(size(head%vcoord).ne.(head%levs+1)*head%nvcoord) return
+      write(lu,iostat=ios) head%vcoord
+      if(ios.ne.0) return
+      if(size(head%cfvars).ne.5+head%ntrac) return
+      write(lu,iostat=ios) head%cfvars
+      if(ios.ne.0) return
+      if (mod(head%idvm/10,10) == 3) then
+        write(lu,iostat=ios) head%cpi
+        if(ios.ne.0) return
+        write(lu,iostat=ios) head%ri
+        if(ios.ne.0) return
+      endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      head2%fhour=head%fhour 
+      head2%idate=head%idate 
+      head2%sisl=0
+      if(head%idvc.eq.0.or.head%idvc.eq.1) then
+        if(head%nvcoord.eq.1.and.head%vcoord(1,1).eq.1.) then
+          head2%sisl(1:head%levs+1)=head%vcoord(1:head%levs+1,1)
+          call sigio_modpr(1,1,head%levs,head%nvcoord,head%idvc,head%idsl,&
+                           head%vcoord,iret,ps=(/1./),&
+                           pm=head2%sisl(head%levs+2:2*head%levs+1))
+        else
+          head2%sisl(1:head%levs+1)=head%si(1:head%levs+1)
+          head2%sisl(head%levs+2:2*head%levs+1)=head%sl(1:head%levs)
+        endif
+      elseif(head%idvc.eq.2) then
+        if(head%nvcoord.eq.2.and.head%vcoord(1,2).eq.1.) then
+          head2%sisl(1:head%levs+1)=head%vcoord(1:head%levs+1,1)
+          head2%sisl(head%levs+2:2*head%levs+2)=head%vcoord(1:head%levs+1,2)
+        else
+          head2%sisl(1:head%levs+1)=head%ak(1:head%levs+1)
+          head2%sisl(head%levs+2:2*head%levs+2)=head%bk(1:head%levs+1)
+        endif
+      elseif(head%idvc.eq.3) then
+        if(head%nvcoord.eq.2.and.head%vcoord(1,2).eq.1.) then
+          head2%sisl(1:head%levs+1)=head%vcoord(1:head%levs+1,1)
+          head2%sisl(head%levs+2:2*head%levs+2)=head%vcoord(1:head%levs+1,2)
+        endif
+      endif
+      head2%ext(1)=head%jcap
+      head2%ext(2)=head%levs
+      head2%ext(3)=head%itrun
+      head2%ext(4)=head%iorder
+      head2%ext(5)=head%irealf
+      head2%ext(6)=head%igen
+      head2%ext(7)=head%lonf
+      head2%ext(8)=head%latf
+      head2%ext(9)=head%lonb
+      head2%ext(10)=head%latb
+      head2%ext(11)=head%lonr
+      head2%ext(12)=head%latr
+      head2%ext(13)=head%ntrac
+      head2%ext(14)=head%icen2
+      head2%ext(15:16)=head%iens
+      head2%ext(17)=head%idpp
+      head2%ext(18)=head%idsl
+      head2%ext(19)=head%idvc
+      head2%ext(20)=head%idvm
+      head2%ext(21)=head%idvt
+      head2%ext(22)=head%idrun
+      head2%ext(23)=head%idusr
+      head2%ext(24)=head%pdryini
+      head2%ext(25)=head%ncldt
+      head2%ext(26)=head%ixgr
+      head2%ext(27)=head%ixga
+      head2%ext(28:44)=0
+      write(lu,iostat=ios) head%clabsig
+      if(ios.ne.0) return
+      write(lu,iostat=ios) head2%fhour,head2%idate,head2%sisl,head2%ext
+      if(ios.ne.0) return
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    iret=0
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_alhead(head,iret,levs,nvcoord,ntrac,idvm)
+    implicit none
+    type(sigio_head),intent(inout):: head
+    integer(sigio_intkind),intent(out):: iret
+    integer(sigio_intkind),optional,intent(in):: levs,nvcoord,ntrac,idvm
+    integer dim1v,dim2v,dim1c,thermodyn_id
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(present(levs)) then
+      dim1v=levs+1
+    else
+      dim1v=head%levs+1
+    endif
+    if(present(nvcoord)) then
+      dim2v=nvcoord
+    else
+      dim2v=head%nvcoord
+    endif
+    if(present(ntrac)) then
+      dim1c=5+ntrac
+    else
+      dim1c=5+head%ntrac
+    endif
+    if(allocated(head%vcoord)) deallocate(head%vcoord)
+    if(allocated(head%cfvars)) deallocate(head%cfvars)
+    allocate(head%vcoord(dim1v,dim2v),head%cfvars(dim1c),stat=iret)
+    if(present(idvm)) then
+      thermodyn_id=mod(idvm/10,10)
+    else
+      thermodyn_id=mod(head%idvm/10,10)
+    endif
+    if (thermodyn_id == 3) then
+      if(allocated(head%cpi)) deallocate(head%cpi)
+      if(allocated(head%ri)) deallocate(head%ri)
+      allocate(head%cpi(dim1c-4),head%ri(dim1c-4),stat=iret)
+    endif
+    if(iret.eq.0) then
+      head%vcoord=sigio_realfill
+      head%cfvars=' '
+    endif
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldata(head,data,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    type(sigio_data),intent(inout):: data
+    integer(sigio_intkind),intent(out):: iret
+    integer nc,dim1,dim2,dim3q,dim1x,dim2x,dim3x
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_axdata(data,iret)
+    nc=(head%jcap+1)*(head%jcap+2)
+    dim1=nc
+    dim2=head%levs
+    dim3q=head%ntrac
+    dim1x=head%lonb
+    dim2x=head%latb
+    dim3x=head%nxgr
+    allocate(data%hs(dim1),data%ps(dim1),&
+             data%t(dim1,dim2),data%d(dim1,dim2),data%z(dim1,dim2),&
+             data%q(dim1,dim2,dim3q),&
+             data%xgr(dim1x,dim2x,dim3x),data%xss(head%nxss),stat=iret)
+    if(iret.ne.0) iret=-3
+
+    dim1x=head%lonf
+    dim2x=head%latf
+    dim3x=head%nxga
+    allocate(data%xga(dim1x,dim2x,dim3x),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdata(data,iret)
+    implicit none
+    type(sigio_data),intent(inout):: data
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    deallocate(data%hs,data%ps,data%t,data%d,data%z,data%q,data%xgr,data%xga,stat=iret)
+    nullify(data%hs,data%ps,data%t,data%d,data%z,data%q,data%xgr,data%xga)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_srdata(lu,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_data),intent(inout):: data
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_dbta):: dbta
+    integer:: nc,mdim1,mdim2,mdim3q,mdim1x,mdim2x,mdim3x,k,n,ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    nc=(head%jcap+1)*(head%jcap+2)
+    mdim1=min(size(data%hs,1),size(data%ps,1),&
+              size(data%t,1),size(data%d,1),size(data%z,1),&
+              size(data%q,1))
+    mdim2=min(size(data%t,2),size(data%d,2),size(data%z,2),&
+              size(data%q,2))
+    mdim3q=size(data%q,3)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    if(head%nxgr.gt.0) then
+      mdim1x=size(data%xgr,1)
+      mdim2x=size(data%xgr,2)
+      mdim3x=size(data%xgr,3)
+      if(mdim1x.lt.head%lonb.or.&
+         mdim2x.lt.head%latb.or.&
+         mdim3x.lt.head%nxgr) return
+      if(size(data%xss).lt.head%nxss) return
+    endif
+    if(head%nxga.gt.0) then
+      mdim1x=size(data%xga,1)
+      mdim2x=size(data%xga,2)
+      mdim3x=size(data%xga,3)
+      if(mdim1x.lt.head%lonf.or.&
+         mdim2x.lt.head%latf.or.&
+         mdim3x.lt.head%nxga) return
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iret=-4
+      read(lu,iostat=ios) data%hs(:nc)
+      if(ios.ne.0) return
+      read(lu,iostat=ios) data%ps(:nc)
+      if(ios.ne.0) return
+      do k=1,head%levs
+        read(lu,iostat=ios) data%t(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do k=1,head%levs
+        read(lu,iostat=ios) data%d(:nc,k)
+        if(ios.ne.0) return
+        read(lu,iostat=ios) data%z(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          read(lu,iostat=ios) data%q(:nc,k,n)
+          if(ios.ne.0) return
+        enddo
+      enddo
+      do n=1,head%nxgr
+        read(lu,iostat=ios) data%xgr(:head%lonb,:head%latb,n)
+        if(ios.ne.0) return
+      enddo
+      if(head%nxss.gt.0) then
+        read(lu,iostat=ios) data%xss(:head%nxss)
+        if(ios.ne.0) return
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        read(lu,iostat=ios) data%xga(:head%lonf,:head%latf,n)
+        if(ios.ne.0) return
+      enddo
+      endif
+      iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      call sigio_aldbta(head,dbta,iret)
+      if(iret.ne.0) return
+      call sigio_srdbta(lu,head,dbta,iret)
+      if(iret.ne.0) return
+      data%hs(:nc)=dbta%hs(:nc)
+      data%ps(:nc)=dbta%ps(:nc)
+      data%t(:nc,:head%levs)=dbta%t(:nc,:head%levs)
+      data%d(:nc,:head%levs)=dbta%d(:nc,:head%levs)
+      data%z(:nc,:head%levs)=dbta%z(:nc,:head%levs)
+      data%q(:nc,:head%levs,:head%ntrac)=dbta%q(:nc,:head%levs,:head%ntrac)
+      data%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       dbta%xgr(:head%lonb,:head%latb,:head%nxgr)
+      data%xss(:head%nxss)=dbta%xss(:head%nxss)
+      data%xga(:head%lonf,:head%latf,:head%nxga)=&
+       dbta%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_axdbta(dbta,iret)
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_swdata(lu,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_data),intent(in):: data
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_dbta):: dbta
+    integer:: nc,mdim1,mdim2,mdim3q,mdim1x,mdim2x,mdim3x,k,n,ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    nc=(head%jcap+1)*(head%jcap+2)
+    mdim1=min(size(data%hs,1),size(data%ps,1),&
+              size(data%t,1),size(data%d,1),size(data%z,1),&
+              size(data%q,1))
+    mdim2=min(size(data%t,2),size(data%d,2),size(data%z,2),&
+              size(data%q,2))
+    mdim3q=size(data%q,3)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    if(head%nxgr.gt.0) then
+      mdim1x=size(data%xgr,1)
+      mdim2x=size(data%xgr,2)
+      mdim3x=size(data%xgr,3)
+      if(mdim1x.lt.head%lonb.or.&
+         mdim2x.lt.head%latb.or.&
+         mdim3x.lt.head%nxgr) return
+      if(size(data%xss).lt.head%nxss) return
+    endif
+    if(head%nxga.gt.0) then
+      mdim1x=size(data%xga,1)
+      mdim2x=size(data%xga,2)
+      mdim3x=size(data%xga,3)
+      if(mdim1x.lt.head%lonf.or.&
+         mdim2x.lt.head%latf.or.&
+         mdim3x.lt.head%nxga) return
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iret=-4
+      write(lu,iostat=ios) data%hs(:nc)
+      if(ios.ne.0) return
+      write(lu,iostat=ios) data%ps(:nc)
+      if(ios.ne.0) return
+      do k=1,head%levs
+        write(lu,iostat=ios) data%t(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do k=1,head%levs
+        write(lu,iostat=ios) data%d(:nc,k)
+        if(ios.ne.0) return
+        write(lu,iostat=ios) data%z(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          write(lu,iostat=ios) data%q(:nc,k,n)
+          if(ios.ne.0) return
+        enddo
+      enddo
+      do n=1,head%nxgr
+        write(lu,iostat=ios) data%xgr(:head%lonb,:head%latb,n)
+        if(ios.ne.0) return
+      enddo
+      if(head%nxss.gt.0) then
+        write(lu,iostat=ios) data%xss(:head%nxss)
+        if(ios.ne.0) return
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        write(lu,iostat=ios) data%xga(:head%lonf,:head%latf,n)
+        if(ios.ne.0) return
+      enddo
+      endif
+      iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      call sigio_aldbta(head,dbta,iret)
+      if(iret.ne.0) return
+      dbta%hs(:nc)=data%hs(:nc)
+      dbta%ps(:nc)=data%ps(:nc)
+      dbta%t(:nc,:head%levs)=data%t(:nc,:head%levs)
+      dbta%d(:nc,:head%levs)=data%d(:nc,:head%levs)
+      dbta%z(:nc,:head%levs)=data%z(:nc,:head%levs)
+      dbta%q(:nc,:head%levs,:head%ntrac)=data%q(:nc,:head%levs,:head%ntrac)
+      dbta%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       data%xgr(:head%lonb,:head%latb,:head%nxgr)
+      dbta%xss(:head%nxss)=data%xss(:head%nxss)
+      dbta%xga(:head%lonf,:head%latf,:head%nxga)=&
+       data%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_swdbta(lu,head,dbta,iret)
+      if(iret.ne.0) return
+      call sigio_axdbta(dbta,iret)
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_srohdca(lu,cfname,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_data),intent(inout):: data
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_sropen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_srhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_aldata(head,data,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_srdata(lu,head,data,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_sclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_swohdca(lu,cfname,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_data),intent(in):: data
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_swopen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_swhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_swdata(lu,head,data,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_sclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldbta(head,dbta,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    type(sigio_dbta),intent(inout):: dbta
+    integer(sigio_intkind),intent(out):: iret
+    integer nc,dim1,dim2,dim3q,dim1x,dim2x,dim3x
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_axdbta(dbta,iret)
+    nc=(head%jcap+1)*(head%jcap+2)
+    dim1=nc
+    dim2=head%levs
+    dim3q=head%ntrac
+    dim1x=head%lonb
+    dim2x=head%latb
+    dim3x=head%nxgr
+    allocate(dbta%hs(dim1),dbta%ps(dim1),&
+             dbta%t(dim1,dim2),dbta%d(dim1,dim2),dbta%z(dim1,dim2),&
+             dbta%q(dim1,dim2,dim3q),&
+             dbta%xgr(dim1x,dim2x,dim3x),dbta%xss(head%nxss),stat=iret)
+    if(iret.ne.0) iret=-3
+    dim1x=head%lonf
+    dim2x=head%latf
+    dim3x=head%nxga
+    allocate(dbta%xga(dim1x,dim2x,dim3x),stat=iret)
+    if(iret.ne.0) iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdbta(dbta,iret)
+    implicit none
+    type(sigio_dbta),intent(inout):: dbta
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    deallocate(dbta%hs,dbta%ps,dbta%t,dbta%d,dbta%z,dbta%q,dbta%xgr,dbta%xga,stat=iret)
+    nullify(dbta%hs,dbta%ps,dbta%t,dbta%d,dbta%z,dbta%q,dbta%xgr,dbta%xga)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_srdbta(lu,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbta),intent(inout):: dbta
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_data):: data
+    integer:: nc,mdim1,mdim2,mdim3q,mdim1x,mdim2x,mdim3x,k,n,ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    nc=(head%jcap+1)*(head%jcap+2)
+    mdim1=min(size(dbta%hs,1),size(dbta%ps,1),&
+              size(dbta%t,1),size(dbta%d,1),size(dbta%z,1),&
+              size(dbta%q,1))
+    mdim2=min(size(dbta%t,2),size(dbta%d,2),size(dbta%z,2),&
+              size(dbta%q,2))
+    mdim3q=size(dbta%q,3)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    if(head%nxgr.gt.0) then
+      mdim1x=size(dbta%xgr,1)
+      mdim2x=size(dbta%xgr,2)
+      mdim3x=size(dbta%xgr,3)
+      if(mdim1x.lt.head%lonb.or.&
+         mdim2x.lt.head%latb.or.&
+         mdim3x.lt.head%nxgr) return
+      if(size(dbta%xss).lt.head%nxss) return
+    endif
+    if(head%nxga.gt.0) then
+      mdim1x=size(dbta%xga,1)
+      mdim2x=size(dbta%xga,2)
+      mdim3x=size(dbta%xga,3)
+      if(mdim1x.lt.head%lonf.or.&
+         mdim2x.lt.head%latf.or.&
+         mdim3x.lt.head%nxga) return
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      call sigio_aldata(head,data,iret)
+      if(iret.ne.0) return
+      call sigio_srdata(lu,head,data,iret)
+      if(iret.ne.0) return
+      dbta%hs(:nc)=data%hs(:nc)
+      dbta%ps(:nc)=data%ps(:nc)
+      dbta%t(:nc,:head%levs)=data%t(:nc,:head%levs)
+      dbta%d(:nc,:head%levs)=data%d(:nc,:head%levs)
+      dbta%z(:nc,:head%levs)=data%z(:nc,:head%levs)
+      dbta%q(:nc,:head%levs,:head%ntrac)=data%q(:nc,:head%levs,:head%ntrac)
+      dbta%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       data%xgr(:head%lonb,:head%latb,:head%nxgr)
+      dbta%xss(:head%nxss)=data%xss(:head%nxss)
+      dbta%xga(:head%lonf,:head%latf,:head%nxga)=&
+       data%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_axdata(data,iret)
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      iret=-4
+      read(lu,iostat=ios) dbta%hs(:nc)
+      if(ios.ne.0) return
+      read(lu,iostat=ios) dbta%ps(:nc)
+      if(ios.ne.0) return
+      do k=1,head%levs
+        read(lu,iostat=ios) dbta%t(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do k=1,head%levs
+        read(lu,iostat=ios) dbta%d(:nc,k)
+        if(ios.ne.0) return
+        read(lu,iostat=ios) dbta%z(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          read(lu,iostat=ios) dbta%q(:nc,k,n)
+          if(ios.ne.0) return
+        enddo
+      enddo
+      do n=1,head%nxgr
+        read(lu,iostat=ios) dbta%xgr(:head%lonb,:head%latb,n)
+        if(ios.ne.0) return
+      enddo
+      if(head%nxss.gt.0) then
+        read(lu,iostat=ios) dbta%xss(:head%nxss)
+        if(ios.ne.0) return
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        read(lu,iostat=ios) dbta%xga(:head%lonf,:head%latf,n)
+        if(ios.ne.0) return
+      enddo
+      endif
+      iret=0
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_swdbta(lu,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbta),intent(in):: dbta
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_data):: data
+    integer:: nc,mdim1,mdim2,mdim3q,mdim1x,mdim2x,mdim3x,k,n,ios
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    nc=(head%jcap+1)*(head%jcap+2)
+    mdim1=min(size(dbta%hs,1),size(dbta%ps,1),&
+              size(dbta%t,1),size(dbta%d,1),size(dbta%z,1),&
+              size(dbta%q,1))
+    mdim2=min(size(dbta%t,2),size(dbta%d,2),size(dbta%z,2),&
+              size(dbta%q,2))
+    mdim3q=size(dbta%q,3)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    if(head%nxgr.gt.0) then
+      mdim1x=size(dbta%xgr,1)
+      mdim2x=size(dbta%xgr,2)
+      mdim3x=size(dbta%xgr,3)
+      if(mdim1x.lt.head%lonb.or.&
+         mdim2x.lt.head%latb.or.&
+         mdim3x.lt.head%nxgr) return
+      if(size(dbta%xss).lt.head%nxss) return
+    endif
+    if(head%nxga.gt.0) then
+      mdim1x=size(dbta%xga,1)
+      mdim2x=size(dbta%xga,2)
+      mdim3x=size(dbta%xga,3)
+      if(mdim1x.lt.head%lonf.or.&
+         mdim2x.lt.head%latf.or.&
+         mdim3x.lt.head%nxga) return
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      call sigio_aldata(head,data,iret)
+      if(iret.ne.0) return
+      data%hs(:nc)=dbta%hs(:nc)
+      data%ps(:nc)=dbta%ps(:nc)
+      data%t(:nc,:head%levs)=dbta%t(:nc,:head%levs)
+      data%d(:nc,:head%levs)=dbta%d(:nc,:head%levs)
+      data%z(:nc,:head%levs)=dbta%z(:nc,:head%levs)
+      data%q(:nc,:head%levs,:head%ntrac)=dbta%q(:nc,:head%levs,:head%ntrac)
+      data%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       dbta%xgr(:head%lonb,:head%latb,:head%nxgr)
+      data%xss(:head%nxss)=dbta%xss(:head%nxss)
+      data%xga(:head%lonf,:head%latf,:head%nxga)=&
+       dbta%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_swdata(lu,head,data,iret)
+      if(iret.ne.0) return
+      call sigio_axdata(data,iret)
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      iret=-4
+      write(lu,iostat=ios) dbta%hs(:nc)
+      if(ios.ne.0) return
+      write(lu,iostat=ios) dbta%ps(:nc)
+      if(ios.ne.0) return
+      do k=1,head%levs
+        write(lu,iostat=ios) dbta%t(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do k=1,head%levs
+        write(lu,iostat=ios) dbta%d(:nc,k)
+        if(ios.ne.0) return
+        write(lu,iostat=ios) dbta%z(:nc,k)
+        if(ios.ne.0) return
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          write(lu,iostat=ios) dbta%q(:nc,k,n)
+          if(ios.ne.0) return
+        enddo
+      enddo
+      do n=1,head%nxgr
+        write(lu,iostat=ios) dbta%xgr(:head%lonb,:head%latb,n)
+        if(ios.ne.0) return
+      enddo
+      if(head%nxss.gt.0) then
+        write(lu,iostat=ios) dbta%xss(:head%nxss)
+        if(ios.ne.0) return
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        write(lu,iostat=ios) dbta%xga(:head%lonf,:head%latf,n)
+        if(ios.ne.0) return
+      enddo
+      endif
+      iret=0
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_srohdcb(lu,cfname,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_dbta),intent(inout):: dbta
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_sropen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_srhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_aldbta(head,dbta,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_srdbta(lu,head,dbta,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_sclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_swohdcb(lu,cfname,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_dbta),intent(in):: dbta
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_swopen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_swhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_swdbta(lu,head,dbta,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_sclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_modpr(im,ix,km,nvcoord,idvc,idsl,vcoord,iret,&
+                         ps,t,pd,dpddps,dpddt,pm,dpmdps,dpmdt)
+    implicit none
+    integer,intent(in):: im,ix,km,nvcoord,idvc,idsl
+    real,intent(in):: vcoord(km+1,nvcoord)
+    integer,intent(out):: iret
+    real,intent(in),optional:: ps(ix),t(ix,km)
+    real,intent(out),optional:: pd(ix,km),pm(ix,km)
+    real,intent(out),optional:: dpddps(ix,km),dpddt(ix,km)
+    real,intent(out),optional:: dpmdps(ix,km),dpmdt(ix,km)
+    real(sigio_dblekind),parameter:: rocp=287.05/1004.6,rocpr=1/rocp
+    real(sigio_dblekind),parameter:: t00=300.
+    integer id1,id2
+    real(sigio_dblekind) pid(im),dpiddps(im),dpiddt(im),tid(im),pidk(im)
+    real(sigio_dblekind) piu,dpiudps,dpiudt,tiu,piuk
+    real(sigio_dblekind) pmm,dpmdpid,dpmdpiu
+    real(sigio_dblekind) pmk
+    integer i,k
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if((idvc.eq.0.or.idvc.eq.1).and.nvcoord.eq.1.and.present(ps)) then
+      id1=11
+    elseif(idvc.eq.2.and.nvcoord.eq.2.and.present(ps)) then
+      id1=22
+    elseif(idvc.eq.3.and.nvcoord.eq.3.and.all(vcoord(:,3).eq.0).and.present(ps)) then
+      id1=22
+    elseif(idvc.eq.3.and.nvcoord.eq.2.and.present(ps).and.present(t)) then
+      id1=32
+    elseif(idvc.eq.3.and.nvcoord.eq.3.and.present(ps).and.present(t)) then
+      id1=33
+    else
+      id1=0
+    endif
+    if(idsl.eq.0.or.idsl.eq.1) then
+      id2=1
+    elseif(idsl.eq.2) then
+      id2=2
+    else
+      id2=0
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(id1.gt.0.and.id2.gt.0) then
+!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(i)
+      do i=1,im
+        pid(i)=ps(i)
+        dpiddps(i)=1
+        dpiddt(i)=0
+        tid(i)=0
+        if(id2.eq.1) pidk(i)=pid(i)**rocp
+      enddo
+!$OMP END PARALLEL DO
+
+!!$OMP PARALLEL DO DEFAULT(SHARED) &
+!!$OMP& PRIVATE(i,k,piu,dpiudps,dpiudt,tiu,piuk,pmk,pmm,dpmdpid,dpmdpiu) &
+!!$OMP& PRIVATE(pid,dpiddps,dpiddt,tid,pidk)
+
+      do k=1,km
+!$OMP PARALLEL DO DEFAULT(SHARED) &
+!$OMP& PRIVATE(i,piu,dpiudps,dpiudt,tiu,piuk,pmk,pmm,dpmdpid,dpmdpiu)
+        do i=1,im
+          select case(id1)
+          case(11)
+            piu=vcoord(k+1,1)*ps(i)
+            dpiudps=vcoord(k+1,1)
+            dpiudt=0
+          case(22)
+            piu=vcoord(k+1,1)+vcoord(k+1,2)*ps(i)
+            dpiudps=vcoord(k+1,2)
+            dpiudt=0
+          case(32)
+            tiu=(t(i,k)+t(i,min(k+1,km)))/2
+            piu=vcoord(k+1,2)*ps(i)+vcoord(k+1,1)*(tiu/t00)**rocpr
+            dpiudps=vcoord(k+1,2)
+            dpiudt=vcoord(k+1,1)*(tiu/t00)**rocpr*rocpr/tiu
+            if(k.lt.km) dpiudt=dpiudt/2
+          case(33)
+            tiu=(t(i,k)+t(i,min(k+1,km)))/2
+            piu=vcoord(k+1,1)+vcoord(k+1,2)*ps(i)+vcoord(k+1,3)*(tiu/t00)**rocpr
+            dpiudps=vcoord(k+1,2)
+            dpiudt=vcoord(k+1,3)*(tiu/t00)**rocpr*rocpr/tiu
+            if(k.lt.km) dpiudt=dpiudt/2
+          end select
+          if(present(pd)) pd(i,k)=pid(i)-piu
+          if(present(dpddps)) dpddps(i,k)=dpiddps(i)-dpiudps
+          if(present(dpddt)) dpddt(i,k)=dpiddt(i)-dpiudt
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+          select case(id2)
+          case(1)
+            piuk=piu**rocp
+            pmk=(pid(i)*pidk(i)-piu*piuk)/((rocp+1)*(pid(i)-piu))
+            pmm=pmk**rocpr
+            dpmdpid=rocpr*pmm/(pid(i)-piu)*(pidk(i)/pmk-1)
+            dpmdpiu=rocpr*pmm/(pid(i)-piu)*(1-piuk/pmk)
+          case(2)
+            pmm=(pid(i)+piu)/2
+            dpmdpid=0.5
+            dpmdpiu=0.5
+          end select
+          if(present(pm)) pm(i,k)=pmm
+          if(present(dpmdps)) dpmdps(i,k)=dpmdpid*dpiddps(i)+dpmdpiu*dpiudps
+          if(present(dpmdt)) dpmdt(i,k)=dpmdpid*dpiddt(i)+dpmdpiu*dpiudt
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+          pid(i)=piu
+          dpiddps(i)=dpiudps
+          dpiddt(i)=dpiudt
+          tid(i)=tiu
+          if(id2.eq.1) pidk(i)=piuk
+        enddo
+!$OMP END PARALLEL DO
+      enddo
+!!$OMP END PARALLEL DO
+    else
+      if(id1.le.0) iret=iret+1
+      if(id2.le.0) iret=iret+2
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_modprd(im,ix,km,nvcoord,idvc,idsl,vcoord,iret,&
+                          ps,t,pd,dpddps,dpddt,pm,dpmdps,dpmdt)
+    implicit none
+    integer,intent(in):: im,ix,km,nvcoord,idvc,idsl
+    real(sigio_dblekind),intent(in):: vcoord(km+1,nvcoord)
+    integer,intent(out):: iret
+    real(sigio_dblekind),intent(in),optional:: ps(ix),t(ix,km)
+    real(sigio_dblekind),intent(out),optional:: pd(ix,km),pm(ix,km)
+    real(sigio_dblekind),intent(out),optional:: dpddps(ix,km),dpddt(ix,km)
+    real(sigio_dblekind),intent(out),optional:: dpmdps(ix,km),dpmdt(ix,km)
+    real(sigio_dblekind),parameter:: rocp=287.05/1004.6,rocpr=1/rocp
+    real(sigio_dblekind),parameter:: t00=300.
+    integer id1,id2
+    real(sigio_dblekind) pid(im),dpiddps(im),dpiddt(im),tid(im),pidk(im)
+    real(sigio_dblekind) piu,dpiudps,dpiudt,tiu,piuk
+    real(sigio_dblekind) pmm,dpmdpid,dpmdpiu
+    real(sigio_dblekind) pmk
+    integer i,k
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if((idvc.eq.0.or.idvc.eq.1).and.nvcoord.eq.1.and.present(ps)) then
+      id1=11
+    elseif(idvc.eq.2.and.nvcoord.eq.2.and.present(ps)) then
+      id1=22
+    elseif(idvc.eq.3.and.nvcoord.eq.3.and.all(vcoord(:,3).eq.0).and.present(ps)) then
+      id1=22
+    elseif(idvc.eq.3.and.nvcoord.eq.2.and.present(ps).and.present(t)) then
+      id1=32
+    elseif(idvc.eq.3.and.nvcoord.eq.3.and.present(ps).and.present(t)) then
+      id1=33
+    else
+      id1=0
+    endif
+    if(idsl.eq.0.or.idsl.eq.1) then
+      id2=1
+    elseif(idsl.eq.2) then
+      id2=2
+    else
+      id2=0
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(id1.gt.0.and.id2.gt.0) then
+!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(i)
+      do i=1,im
+        pid(i)=ps(i)
+        dpiddps(i)=1
+        dpiddt(i)=0
+        tid(i)=0
+        if(id2.eq.1) pidk(i)=pid(i)**rocp
+      enddo
+!$OMP END PARALLEL DO
+
+!!$OMP PARALLEL DO DEFAULT(SHARED) &
+!!$OMP& PRIVATE(i,k,piu,dpiudps,dpiudt,tiu,piuk,pmk,pmm,dpmdpid,dpmdpiu) &
+!!$OMP& PRIVATE(pid,dpiddps,dpiddt,tid,pidk)
+
+      do k=1,km
+!$OMP PARALLEL DO DEFAULT(SHARED) &
+!$OMP& PRIVATE(i,piu,dpiudps,dpiudt,tiu,piuk,pmk,pmm,dpmdpid,dpmdpiu)
+        do i=1,im
+          select case(id1)
+          case(11)
+            piu=vcoord(k+1,1)*ps(i)
+            dpiudps=vcoord(k+1,1)
+            dpiudt=0
+          case(22)
+            piu=vcoord(k+1,1)+vcoord(k+1,2)*ps(i)
+            dpiudps=vcoord(k+1,2)
+            dpiudt=0
+          case(32)
+            tiu=(t(i,k)+t(i,min(k+1,km)))/2
+            piu=vcoord(k+1,2)*ps(i)+vcoord(k+1,1)*(tiu/t00)**rocpr
+            dpiudps=vcoord(k+1,2)
+            dpiudt=vcoord(k+1,1)*(tiu/t00)**rocpr*rocpr/tiu
+            if(k.lt.km) dpiudt=dpiudt/2
+          case(33)
+            tiu=(t(i,k)+t(i,min(k+1,km)))/2
+            piu=vcoord(k+1,1)+vcoord(k+1,2)*ps(i)+vcoord(k+1,3)*(tiu/t00)**rocpr
+            dpiudps=vcoord(k+1,2)
+            dpiudt=vcoord(k+1,3)*(tiu/t00)**rocpr*rocpr/tiu
+            if(k.lt.km) dpiudt=dpiudt/2
+          end select
+          if(present(pd)) pd(i,k)=pid(i)-piu
+          if(present(dpddps)) dpddps(i,k)=dpiddps(i)-dpiudps
+          if(present(dpddt)) dpddt(i,k)=dpiddt(i)-dpiudt
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+          select case(id2)
+          case(1)
+            piuk=piu**rocp
+            pmk=(pid(i)*pidk(i)-piu*piuk)/((rocp+1)*(pid(i)-piu))
+            pmm=pmk**rocpr
+            dpmdpid=rocpr*pmm/(pid(i)-piu)*(pidk(i)/pmk-1)
+            dpmdpiu=rocpr*pmm/(pid(i)-piu)*(1-piuk/pmk)
+          case(2)
+            pmm=(pid(i)+piu)/2
+            dpmdpid=0.5
+            dpmdpiu=0.5
+          end select
+          if(present(pm)) pm(i,k)=pmm
+          if(present(dpmdps)) dpmdps(i,k)=dpmdpid*dpiddps(i)+dpmdpiu*dpiudps
+          if(present(dpmdt)) dpmdt(i,k)=dpmdpid*dpiddt(i)+dpmdpiu*dpiudt
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+          pid(i)=piu
+          dpiddps(i)=dpiudps
+          dpiddt(i)=dpiudt
+          tid(i)=tiu
+          if(id2.eq.1) pidk(i)=piuk
+        enddo
+!$OMP END PARALLEL DO
+      enddo
+!!$OMP END PARALLEL DO
+    else
+      if(id1.le.0) iret=iret+1
+      if(id2.le.0) iret=iret+2
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_adhead(head)
+    implicit none
+    type(sigio_head),intent(inout):: head
+    integer jxss,nspec,n1,n2
+    integer a, b, c                        
+    integer n3dzhaocld, n3dfercld, n3dcldpdf, n3dflxtvd
+    integer n2dzhaocld, n2dfercld, n2dcldpdf, n2dflxtvd
+    integer num_p3d, num_p2d, num_a3d, num_a2d
+
+!--for physics
+    head%nxgr=0
+    head%nxss=0
+    n3dzhaocld=0; n3dfercld=0; n3dcldpdf=0
+    n2dzhaocld=0; n2dfercld=0; n2dcldpdf=0
+
+    a=mod(head%ixgr,10)
+    b=int(mod(head%ixgr,100)/10)
+    c=int(mod(head%ixgr,1000)/100)
+    if (a.eq.1) then
+     n2dzhaocld=0
+     n3dzhaocld=2
+     head%nxss=0
+    else if (a.eq.2) then
+     n2dzhaocld=2
+     n3dzhaocld=4
+     head%nxss=0
+    else if (a.eq.3) then
+     n2dzhaocld=2
+     n3dzhaocld=4
+     head%nxss=1
+    endif
+
+    if (b.eq.1) then
+     n2dfercld=0
+     n3dfercld=3
+     head%nxss=0
+    else if (b.eq.2) then
+     n2dfercld=0
+     n3dfercld=3
+     head%nxss=1
+    endif
+
+    if (c.eq.1) then
+     n2dcldpdf=0
+     n3dcldpdf=3
+    endif
+
+    num_p3d=n3dzhaocld+n3dfercld+n3dcldpdf
+!!  num_p2d=1 is reserved for "ddvel", sfc wind enhancement due to convection
+    num_p2d=1+n2dzhaocld+n2dfercld+n2dcldpdf
+    if(head%ixgr<=0) num_p2d=0
+    head%nxgr=num_p3d*head%levs+num_p2d
+
+!--for dynamics
+    head%nxga=0
+    n3dflxtvd=0
+    n2dflxtvd=0
+
+    a=mod(head%ixga,10)
+    if (a.eq.1) then
+     n2dflxtvd=0  
+     n3dflxtvd=head%ntrac  
+    endif
+
+    num_a3d=n3dflxtvd 
+    num_a2d=n2dflxtvd 
+    head%nxga=num_a3d*head%levs+num_a2d
+
+
+    nspec=2+(3+head%ntrac)*head%levs
+    if(head%ivs.eq.200509) then
+      jxss=0
+      if(head%nxss.gt.0) jxss=1
+      head%nhead=5
+      if (mod(head%idvm/10,10) == 3) then
+        head%nhead=7
+      endif
+      head%ndata=nspec+head%nxgr+jxss+head%nxga
+      if(allocated(head%lhead)) deallocate(head%lhead)
+      if(allocated(head%ldata)) deallocate(head%ldata)
+      allocate(head%lhead(head%nhead))
+      allocate(head%ldata(head%ndata))
+      if (mod(head%idvm/10,10) .ne. 3) then
+        head%lhead=(/sigio_lhead1,4*(head%nhead+head%ndata),4*50,&
+                   4*((head%levs+1)*head%nvcoord),8*(5+head%ntrac)/)
+!     if (mod(head%idvm/10,10) == 3) then
+      else
+        head%lhead=(/sigio_lhead1,4*(head%nhead+head%ndata),4*50,   &
+                   4*((head%levs+1)*head%nvcoord),8*(5+head%ntrac), &
+                   4*(head%ntrac+1), 4*(head%ntrac+1)/)
+!                  400, 400/)
+      endif
+      head%ldata(1:nspec)=4*head%irealf*(head%jcap+1)*(head%jcap+2)
+      n1=nspec+1; n2=nspec+head%nxgr
+      if(head%nxgr>0) head%ldata(n1:n2)=4*head%irealf*head%lonb*head%latb
+      n1=nspec+head%nxgr+1; n2=nspec+head%nxgr+jxss
+      if(jxss>0) head%ldata(n1:n2)=4*head%irealf*head%nxss
+      n1=nspec+head%nxgr+jxss+1; n2=nspec+head%nxgr+jxss+head%nxga
+      if(head%nxga>0) head%ldata(n1:n2)=4*head%irealf*head%lonf*head%latf
+    else
+      head%nhead=2
+      head%ndata=nspec+head%nxgr+head%nxga
+      if(allocated(head%lhead)) deallocate(head%lhead)
+      if(allocated(head%ldata)) deallocate(head%ldata)
+      allocate(head%lhead(head%nhead))
+      allocate(head%ldata(head%ndata))
+      head%lhead=(/sigio_lhead1,4*250/)
+      head%ldata(1:nspec)=4*head%irealf*(head%jcap+1)*(head%jcap+2)
+      head%ldata(nspec+1:nspec+head%nxgr)=4*head%irealf*head%lonb*head%latb
+      head%ldata(nspec+head%nxgr+1:head%ndata)=4*head%irealf*head%lonf*head%latf
+    endif
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_cnvpsv(im,idvm,ps,dp,cnflg)
+    implicit none
+    integer,intent(in)       :: im,idvm,cnflg
+    real,intent(inout)       :: ps(im)
+    real,intent(out)         :: dp(im)
+    integer                  :: surfpress_id
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    surfpress_id = mod(idvm,10)
+    if (cnflg > 0) then
+      if (surfpress_id == 2) then
+        dp=1.e3
+        ps=ps*1.e3
+      else
+        dp=exp(ps)*1.e3
+        ps=exp(ps)*1.e3
+      endif
+    else
+      if (surfpress_id == 2) then
+        dp=1/1.e3
+        ps=ps/1.e3
+      else
+        dp=1/ps
+        ps=log(ps/1.e3)
+      endif
+    endif
+  end subroutine sigio_cnvpsv
+!-------------------------------------------------------------------------------
+  subroutine sigio_cnvtdv(im,ix,km,idvc,idvm,ntrac,iret,t,q,cpi,cnflg)
+    implicit none
+    integer,intent(in):: im,ix,km,idvc,idvm,ntrac,cnflg
+    integer,intent(out):: iret
+    real,intent(in)          :: q(ix,km,ntrac), cpi(0:ntrac)
+    real,intent(inout)       :: t(ix,km)
+    integer                  :: thermodyn_id, n
+    real                     :: xcp(ix,km), sumq(ix,km)
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    thermodyn_id = mod(IDVM/10,10)
+!
+    if (thermodyn_id == 3 .and. idvc == 3) then
+      xcp(1:im,:)  = 0.0
+      sumq(1:im,:) = 0.0
+      do n=1,NTRAC
+        if( cpi(n) .ne. 0.0) then
+           xcp(1:im,:)  = xcp(1:im,:)  + q(1:im,:,n) * cpi(n)
+           sumq(1:im,:) = sumq(1:im,:) + q(1:im,:,n)
+        endif
+      enddo
+      xcp(1:im,:)  = (1.-sumq(1:im,:))*cpi(0) + xcp(1:im,:)   ! Mean Cp
+!
+    else
+      xcp(1:im,:) = (1.+(461.50/287.05-1)*Q(1:im,:,1))        ! Virt factor
+    endif
+    if (cnflg > 0) then
+      t(1:im,:) = t(1:im,:) / xcp(1:im,:)
+    else
+      t(1:im,:) = t(1:im,:) * xcp(1:im,:)
+    endif
+    iret = 0
+!
+    return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine sigio_cnvtdv
+!-------------------------------------------------------------------------------
+  subroutine sigio_cnvpsvd(im,idvm,ps,dp,cnflg)
+    implicit none
+    integer,intent(in)                       :: im,idvm,cnflg
+    real(sigio_dblekind),intent(inout)       :: ps(im)
+    real(sigio_dblekind),intent(out)         :: dp(im)
+    integer                                  :: surfpress_id
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    surfpress_id = mod(idvm,10)
+    if (cnflg > 0) then
+      if (surfpress_id == 2) then
+        dp=1.e3
+        ps=ps*1.e3
+      else
+        dp=exp(ps)*1.e3
+        ps=exp(ps)*1.e3
+      endif
+    else
+      if (surfpress_id == 2) then
+        dp=1/1.e3
+        ps=ps/1.e3
+      else
+        dp=1/ps
+        ps=log(ps/1.e3)
+      endif
+    endif
+  end subroutine sigio_cnvpsvd
+!-------------------------------------------------------------------------------
+  subroutine sigio_cnvtdvd(im,ix,km,idvc,idvm,ntrac,iret,t,q,cpi,cnflg)
+    implicit none
+    integer,intent(in):: im,ix,km,idvc,idvm,ntrac,cnflg
+    integer,intent(out):: iret
+    real(sigio_realkind),intent(in)      :: cpi(0:ntrac)
+    real(sigio_dblekind),intent(in)      :: q(ix,km,ntrac)
+!   real(sigio_dblekind),intent(in)      :: q(ix,km,ntrac), cpi(0:ntrac)
+    real(sigio_dblekind),intent(inout)   :: t(ix,km)
+    integer                              :: thermodyn_id, n
+    real(sigio_dblekind)                 :: xcp(ix,km), sumq(ix,km)
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    thermodyn_id = mod(IDVM/10,10)
+!
+    if (thermodyn_id == 3 .and. idvc == 3) then
+      xcp(1:im,:)  = 0.0
+      sumq(1:im,:) = 0.0
+      do n=1,NTRAC
+        if( cpi(n) .ne. 0.0) then
+           xcp(1:im,:)  = xcp(1:im,:)  + q(1:im,:,n) * cpi(n)
+           sumq(1:im,:) = sumq(1:im,:) + q(1:im,:,n)
+        endif
+      enddo
+      xcp(1:im,:)  = (1.-sumq(1:im,:))*cpi(0) + xcp(1:im,:)   ! Mean Cp
+!
+    else
+      xcp(1:im,:) = (1.+(461.50/287.05-1)*Q(1:im,:,1))        ! Virt factor
+    endif
+    if (cnflg > 0) then
+      t(1:im,:) = t(1:im,:) / xcp(1:im,:)
+    else
+      t(1:im,:) = t(1:im,:) * xcp(1:im,:)
+    endif
+    iret = 0
+!
+    return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine sigio_cnvtdvd
+!-------------------------------------------------------------------------------
+end module
--- sigio_r_module.f.orig	2016-07-01 12:29:26.000000000 -0400
+++ sigio_r_module.f	2016-07-01 12:29:55.000000000 -0400
@@ -0,0 +1,2552 @@
+!-------------------------------------------------------------------------------
+module sigio_r_module
+!$$$  Module Documentation Block
+!
+! Module:    sigio_r_module  API for global spectral sigma file random I/O
+!   Prgmmr: Iredell          Org: W/NX23     Date: 1999-01-18
+!
+! Abstract: This module provides an Application Program Interface extension
+!   for performing I/O on the sigma restart file of the global spectral model.
+!   Functions include opening, reading, writing, and closing as well as
+!   allocating and deallocating data buffers used in the transfers.
+!   The I/O performed here is random.
+!   The transfers are limited to header records, data records,
+!   surface data records, or specific levels of upper air data records.
+!   See the documentation for sigio_module for sequential I/O.
+!   
+! Program History Log:
+!   1999-01-18  Mark Iredell
+!
+! Modules Used:
+!   sigio_module     API for global spectral sigma file I/O
+!
+! Public Variables:
+!
+! Public Defined Types:
+!   sigio_dats       Sigma file surface data fields
+!     hs                Real(sigio_realkind)(:) pointer to spectral
+!                       coefficients of surface height in m
+!     ps                Real(sigio_realkind)(:) pointer to spectral
+!                       coefficients of log of surface pressure over 1 kPa
+!
+!   sigio_datm       Sigma file multilevel data fields
+!     k1                Integer(sigio_intkind) first level number
+!     k2                Integer(sigio_intkind) last level number
+!     t                 Real(sigio_realkind)(:,:) pointer to spectral
+!                       coefficients of virtual temperature by level in K
+!     d                 Real(sigio_realkind)(:,:) pointer to spectral
+!                       coefficients of divergence by level in 1/second
+!     z                 Real(sigio_realkind)(:,:) pointer to spectral
+!                       coefficients of vorticity by level in 1/second
+!     q                 Real(sigio_realkind)(:,:,:) pointer to spectral
+!                       coefficients of tracers by tracer number and level
+!                       in specific densities
+!
+!   sigio_dati       Sigma file single data field
+!     i                 Integer(sigio_intkind) record index
+!     f                 Real(sigio_realkind)(:) pointer to field
+!                       
+!   sigio_dbts       Sigma file longreal surface data fields
+!     hs                Real(sigio_dblekind)(:) pointer to spectral
+!                       coefficients of surface height in m
+!     ps                Real(sigio_dblekind)(:) pointer to spectral
+!                       coefficients of log of surface pressure over 1 kPa
+!
+!   sigio_dbtm       Sigma file longreal multilevel data fields
+!     k1                Integer(sigio_intkind) first level number
+!     k2                Integer(sigio_intkind) last level number
+!     t                 Real(sigio_dblekind)(:,:) pointer to spectral
+!                       coefficients of virtual temperature by level in K
+!     d                 Real(sigio_dblekind)(:,:) pointer to spectral
+!                       coefficients of divergence by level in 1/second
+!     z                 Real(sigio_dblekind)(:,:) pointer to spectral
+!                       coefficients of vorticity by level in 1/second
+!     q                 Real(sigio_dblekind)(:,:,:) pointer to spectral
+!                       coefficients of tracers by tracer number and level
+!                       in specific densities
+!
+!   sigio_dbti       Sigma file longreal single data field
+!     i                 Integer(sigio_intkind) record index
+!     f                 Real(sigio_dblekind)(:) pointer to field
+!                       
+! Public Subprograms:
+!   sigio_rropen     Open sigma file for random reading
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwopen     Open sigma file for random writing
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rxopen     Open sigma file for random reading and writing
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rclose     Close sigma file for random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrhead     Read header information with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) output header information
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwhead     Write header information with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldats     Allocate surface data fields
+!     head              Type(sigio_head) input header information
+!     dats              Type(sigio_dats) output surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdats     Deallocate surface data fields
+!     dats              Type(sigio_dats) output surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldatm     Allocate multilevel data fields
+!     head              Type(sigio_head) input header information
+!     k1                Integer(sigio_intkind) input first level number
+!     k2                Integer(sigio_intkind) input last level number
+!     datm              Type(sigio_datm) output multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdatm     Deallocate multilevel data fields
+!     datm              Type(sigio_datm) output multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldati     Allocate single data fields
+!     head              Type(sigio_head) input header information
+!     i                 Integer(sigio_intkind) input record index
+!     dati              Type(sigio_dati) output single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdati     Deallocate single data fields
+!     dati              Type(sigio_dati) output single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdata     Read data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdata     Write data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) input data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrohdc     Open, read header & data and close with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     head              Type(sigio_head) output header information
+!     data              Type(sigio_data) or type(sigio_dbta) output data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwohdc     Open, write header & data and close with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     cfname            Character(*) input filename
+!     head              Type(sigio_head) input header information
+!     data              Type(sigio_data) or type(sigio_dbta) input data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdats     Read surface data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dats              Type(sigio_dats) output surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdats     Write surface data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dats              Type(sigio_dats) input surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdatm     Read multilevel data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     datm              Type(sigio_datm) output multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdatm     Write multilevel data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     datm              Type(sigio_datm) input multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdati     Read single data field with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dati              Type(sigio_dati) output single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdati     Write single data field with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dati              Type(sigio_dati) input single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldbts     Allocate longreal surface data fields
+!     head              Type(sigio_head) input header information
+!     dbts              Type(sigio_dbts) output longreal surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdbts     Deallocate longreal surface data fields
+!     dbts              Type(sigio_dbts) output longreal surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldbtm     Allocate longreal multilevel data fields
+!     head              Type(sigio_head) input header information
+!     k                 Integer(sigio_intkind) input level number
+!     dbtm              Type(sigio_dbtm) output longreal multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdbtm     Deallocate longreal multilevel data fields
+!     dbtm              Type(sigio_dbtm) output longreal multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_aldbti     Allocate longreal single data fields
+!     head              Type(sigio_head) input header information
+!     i                 Integer(sigio_intkind) input record index
+!     dbti              Type(sigio_dbti) output longreal single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_axdbti     Deallocate longreal single data fields
+!     dbti              Type(sigio_dbti) output longreal single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdbta     Read longreal data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbta              Type(sigio_dbta) output longreal data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdbta     Write longreal data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbta              Type(sigio_dbta) input longreal data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdbts     Read longreal surface data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbts              Type(sigio_dbts) output longreal surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdbts     Write longreal surface data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbts              Type(sigio_dbts) input longreal surface data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdbtm     Read longreal multilevel data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbtm              Type(sigio_dbtm) output longreal multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdbtm     Write longreal multilevel data fields with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbtm              Type(sigio_dbtm) input longreal multilevel data fields
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rrdbti     Read longreal single data field with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbti              Type(sigio_dbti) output longreal single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+!   sigio_rwdbti     Write longreal single data field with random I/O
+!     lu                Integer(sigio_intkind) input logical unit
+!     head              Type(sigio_head) input header information
+!     dbti              Type(sigio_dbti) input longreal single data field
+!     iret              Integer(sigio_intkind) output return code
+!
+! Subprograms called:
+!   baopenr           Byte-addressable open for reading
+!   baopenw           Byte-addressable open for writing
+!   baclose           Byte-addressable close
+!   bafrindexl        Byte-addressable Fortran record index
+!   bafrreadl         Byte-addressable Fortran record read
+!   bafrwritel        Byte-addressable Fortran record write
+!
+! Remarks:
+!   (1) The sigma file format follows:
+!         ON85 label (32 bytes)
+!         Header information record containing
+!           real forecast hour, initial date, sigma interfaces, sigma levels,
+!           padding to allow for 100 levels, and finally 44 identifier words
+!           containing JCAP, LEVS, NTRAC, etc. (250 4-byte words)
+!         Orography (NC 4-byte words, where NC=(JCAP+1)*(JCAP+2))
+!         Log surface pressure (NC 4-byte words)
+!         Temperature (LEVS records of NC 4-byte words)
+!         Divergence & Vorticity interleaved (2*LEVS records of NC 4-byte words)
+!         Tracers (LEVS*NTRAC records of NC 4-byte words)
+!
+!   (2) Possible return codes:
+!          0   Successful call
+!         -1   Open or close I/O error
+!         -2   Header record I/O error (possible EOF)
+!         -3   Allocation or deallocation error
+!         -4   Data record I/O error
+!         -5   Insufficient data dimensions allocated
+!
+! Examples:
+!   (1) Write out orography and surface pressure only from processor 0:
+!
+!     subroutine write_surface_fields(me,head,len,orog,lnps)
+!     use sigio_r_module
+!     integer,intent(in):: me
+!     type(sigio_head),intent(in):: head
+!     integer,intent(in):: len
+!     real(sigio_dblekind),intent(in),target:: orog(len),lnps(len)
+!     type(sigio_dbts) dbts
+!     integer iret
+!     if(me.eq.0) then
+!       dbts%hs=>orog
+!       dbts%ps=>lnps
+!       call sigio_rwdbts(51,head,dbts,iret)
+!     endif
+!     end subroutine
+! 
+! Attributes:
+!   Language: Fortran 90
+!
+!$$$
+  use sigio_module
+  implicit none
+  private
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Public Variables
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Public Types
+  type,public:: sigio_dats
+    real(sigio_realkind),pointer:: hs(:)=>null(),ps(:)=>null();
+  end type
+  type,public:: sigio_datm
+    integer(sigio_intkind):: k1,k2
+    real(sigio_realkind),pointer:: t(:,:)=>null()
+    real(sigio_realkind),pointer:: d(:,:)=>null(),z(:,:)=>null()
+    real(sigio_realkind),pointer:: q(:,:,:)=>null()
+  end type
+  type,public:: sigio_dati
+    integer(sigio_intkind):: i
+    real(sigio_realkind),pointer:: f(:)=>null()
+  end type
+  type,public:: sigio_dbts
+    real(sigio_dblekind),pointer:: hs(:)=>null(),ps(:)=>null()
+  end type
+  type,public:: sigio_dbtm
+    integer(sigio_intkind):: k1,k2
+    real(sigio_dblekind),pointer:: t(:,:)=>null()
+    real(sigio_dblekind),pointer:: d(:,:)=>null(),z(:,:)=>null()
+    real(sigio_dblekind),pointer:: q(:,:,:)=>null()
+  end type
+  type,public:: sigio_dbti
+    integer(sigio_intkind):: i
+    real(sigio_dblekind),pointer:: f(:)=>null()
+  end type
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Private Variables
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Private Types
+  type sigio_head2
+    sequence
+    real(sigio_realkind):: fhour
+    integer(sigio_intkind):: idate(4)
+    real(sigio_realkind):: sisl(2*100+1)
+    real(sigio_realkind):: ext(44)
+  end type
+  type sigio_head1a
+    sequence
+    character(8):: clab8
+    integer(sigio_intkind):: ivs,nhead,ndata,reserved(3)
+  end type
+  type sigio_head3a
+    sequence
+    real(sigio_realkind) fhour
+    integer(sigio_intkind):: idate(4)
+    integer(sigio_intkind):: jcap,levs,&
+      itrun,iorder,irealf,igen,latf,lonf,&
+      latb,lonb,latr,lonr,ntrac,nvcoord,&
+      icen2,iens(2),idpp,idsl,idvc,idvm,&
+      idvt,idrun,idusr
+    real(sigio_realkind) pdryini
+    integer(sigio_intkind):: ncldt,ixgr,ixga
+    integer(sigio_intkind):: reserved(17)
+  end type
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+! Public Subprograms
+  public sigio_rropen,sigio_rwopen,sigio_rxopen,sigio_rclose
+  public sigio_rrhead,sigio_rwhead
+  public sigio_aldats,sigio_axdats
+  public sigio_aldatm,sigio_axdatm
+  public sigio_aldati,sigio_axdati
+  public sigio_rrdata,sigio_rwdata
+  public sigio_rrohdc,sigio_rwohdc
+  public sigio_rrdats,sigio_rwdats
+  public sigio_rrdatm,sigio_rwdatm
+  public sigio_rrdati,sigio_rwdati
+  public sigio_aldbts,sigio_axdbts
+  public sigio_aldbtm,sigio_axdbtm
+  public sigio_aldbti,sigio_axdbti
+  public sigio_rrdbta,sigio_rwdbta
+  public sigio_rrdbts,sigio_rwdbts
+  public sigio_rrdbtm,sigio_rwdbtm
+  public sigio_rrdbti,sigio_rwdbti
+  interface sigio_rrohdc
+    module procedure sigio_rrohdca,sigio_rrohdcb
+  end interface
+  interface sigio_rwohdc
+    module procedure sigio_rwohdca,sigio_rwohdcb
+  end interface
+contains
+!-------------------------------------------------------------------------------
+  subroutine sigio_rropen(lu,cfname,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call baopenr(lu,cfname,iret)
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwopen(lu,cfname,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call baopenw(lu,cfname,iret)
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rxopen(lu,cfname,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call baopen(lu,cfname,iret)
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rclose(lu,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call baclose(lu,iret)
+    if(iret.ne.0) iret=-1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrhead(lu,head,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(inout):: head
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_head2):: head2
+    type(sigio_head1a):: head1a
+    type(sigio_head3a):: head3a
+    integer(8):: iskip,iread,nread
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    iret=-2
+    iskip=0
+    iread=sigio_lhead1
+    call bafrreadl(lu,iskip,iread,nread,head1a)
+    if(nread.lt.iread) return
+!LLF+PM--
+    call byteswap(head1a%ivs,sigio_intkind,6)
+!LLF+PM==
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head1a%clab8.eq.'GFS SIG ') then  ! modern sigma file
+      head%ivs=head1a%ivs
+      call bafrindexl(lu,iskip+nread,nread,iskip)
+      iread=200
+      call bafrreadl(lu,iskip,iread,nread,head3a)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(head3a%fhour,sigio_realkind,1)
+      call byteswap(head3a%idate,sigio_intkind,28)
+      call byteswap(head3a%pdryini,sigio_realkind,1)
+      call byteswap(head3a%ncldt,sigio_intkind,20)
+!LLF+PM==
+      head%fhour=head3a%fhour
+      head%idate=head3a%idate
+      head%jcap=head3a%jcap
+      head%levs=head3a%levs
+      head%itrun=head3a%itrun
+      head%iorder=head3a%iorder
+      head%irealf=head3a%irealf
+      head%igen=head3a%igen
+      head%latf=head3a%latf
+      head%lonf=head3a%lonf
+      head%latb=head3a%latb
+      head%lonb=head3a%lonb
+      head%latr=head3a%latr
+      head%lonr=head3a%lonr
+      head%ntrac=head3a%ntrac
+      head%nvcoord=head3a%nvcoord
+      head%icen2=head3a%icen2
+      head%iens=head3a%iens
+      head%idpp=head3a%idpp
+      head%idsl=head3a%idsl
+      head%idvc=head3a%idvc
+      head%idvm=head3a%idvm
+      head%idvt=head3a%idvt
+      head%idrun=head3a%idrun
+      head%idusr=head3a%idusr
+      head%pdryini=head3a%pdryini
+      head%ncldt=head3a%ncldt
+      head%ixgr=head3a%ixgr
+      head%ixga=head3a%ixga
+      call sigio_alhead(head,iret)
+      iskip=iskip+nread
+      iread=4*size(head%vcoord)
+      call bafrreadl(lu,iskip,iread,nread,head%vcoord)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(head%vcoord,sigio_realkind,iread/4)
+!LLF+PM==
+      iskip=iskip+nread
+      iread=size(head%cfvars)
+      call bafrreadl(lu,iskip,iread,nread,head%cfvars)
+      if(nread.lt.iread) return
+!
+      if (mod(head%idvm/10,10) == 3) then
+        iskip=iskip+nread
+        iread=4*size(head%cpi)
+        call bafrreadl(lu,iskip,iread,nread,head%cpi)
+        if(nread.lt.iread) return
+        call byteswap(head%cpi,sigio_realkind,iread/4)
+        iskip=iskip+nread
+        iread=4*size(head%ri)
+        call bafrreadl(lu,iskip,iread,nread,head%ri)
+        if(nread.lt.iread) return
+        call byteswap(head%ri,sigio_realkind,iread/4)
+      endif
+      head%clabsig=' '
+      head%si=sigio_realfill
+      head%sl=sigio_realfill
+      head%ak=sigio_realfill
+      head%bk=sigio_realfill
+!      head%pdryini=sigio_realfill
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      iskip=0
+      iread=sigio_lhead1
+      call bafrreadl(lu,iskip,iread,nread,head%clabsig)
+      if(nread.lt.iread) return
+      iskip=iskip+nread
+      iread=1000
+      call bafrreadl(lu,iskip,iread,nread,head2)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(head2%fhour,sigio_realkind,1)
+      call byteswap(head2%idate,sigio_intkind,4)
+      call byteswap(head2%sisl,sigio_realkind,245)
+!LLF+PM==
+      iret=0
+      head%fhour=head2%fhour
+      head%idate=head2%idate
+      head%jcap=head2%ext(1)
+      head%levs=head2%ext(2)
+      head%itrun=head2%ext(3)
+      head%iorder=head2%ext(4)
+      head%irealf=head2%ext(5)
+      head%igen=head2%ext(6)
+      head%lonf=head2%ext(7)
+      head%latf=head2%ext(8)
+      head%lonb=head2%ext(9)
+      head%latb=head2%ext(10)
+      head%lonr=head2%ext(11)
+      head%latr=head2%ext(12)
+      head%ntrac=max(head2%ext(13),1.)
+      head%icen2=head2%ext(14)
+      head%iens=head2%ext(15:16)
+      head%idpp=head2%ext(17)
+      head%idsl=head2%ext(18)
+      head%idvc=head2%ext(19)
+      head%idvm=head2%ext(20)
+      head%idvt=head2%ext(21)
+      head%idrun=head2%ext(22)
+      head%idusr=head2%ext(23)
+      head%pdryini=head2%ext(24)
+      head%ncldt=head2%ext(25)
+      head%ixgr=head2%ext(26)
+      head%ixga=head2%ext(27)
+      head%si=sigio_realfill
+      head%sl=sigio_realfill
+      head%ak=sigio_realfill
+      head%bk=sigio_realfill
+      if(head%idvc.eq.2) then
+        head%ak(1:head%levs+1)=head2%sisl(1:head%levs+1)
+        head%bk(1:head%levs+1)=head2%sisl(head%levs+2:2*head%levs+2)
+      else
+        head%si(1:head%levs+1)=head2%sisl(1:head%levs+1)
+        head%sl(1:head%levs)=head2%sisl(head%levs+2:2*head%levs+1)
+      endif
+      head%ivs=198410
+      if(head%idvc.eq.2) then
+        head%nvcoord=2
+        call sigio_alhead(head,iret)
+        head%vcoord(1:head%levs+1,1)=head%ak(1:head%levs+1)
+        head%vcoord(1:head%levs+1,2)=head%bk(1:head%levs+1)
+      elseif(head%idvc.eq.0.or.head%idvc.eq.1) then
+        head%nvcoord=1
+        call sigio_alhead(head,iret)
+        head%vcoord(1:head%levs+1,1)=head%si(1:head%levs+1)
+      endif
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_adhead(head)
+    iret=0
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwhead(lu,head,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(inout):: head
+    integer(sigio_intkind),intent(out):: iret
+    type(sigio_head2):: head2
+    type(sigio_head1a):: head1a
+    integer,allocatable:: head2a(:)
+    type(sigio_head3a):: head3a
+    integer(8):: iskip,iwrite,nwrite
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    iret=-2
+    call sigio_adhead(head)
+    if(head%ivs.ge.200509) then
+      head1a%clab8='GFS SIG '
+      head1a%ivs=head%ivs
+      head1a%nhead=head%nhead
+      head1a%ndata=head%ndata
+      head1a%reserved=0
+      iskip=0
+      iwrite=head%lhead(1)
+!LLF+PM--
+      call byteswap(head1a%ivs,sigio_intkind,6)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,head1a)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(head1a%ivs,sigio_intkind,6)
+!LLF+PM==
+      allocate(head2a(head%nhead+head%ndata))
+      head2a(:head%nhead)=head%lhead
+      head2a(head%nhead+1:)=head%ldata
+      iskip=iskip+nwrite
+      iwrite=head%lhead(2)
+!LLF+PM--
+      call byteswap(head2a,sigio_intkind,iwrite/sigio_intkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,head2a)
+      deallocate(head2a)
+      if(nwrite.lt.iwrite) return
+      head3a%fhour=head%fhour
+      head3a%idate=head%idate
+      head3a%jcap=head%jcap
+      head3a%levs=head%levs
+      head3a%itrun=head%itrun
+      head3a%iorder=head%iorder
+      head3a%irealf=head%irealf
+      head3a%igen=head%igen
+      head3a%latf=head%latf
+      head3a%lonf=head%lonf
+      head3a%latb=head%latb
+      head3a%lonb=head%lonb
+      head3a%latr=head%latr
+      head3a%lonr=head%lonr
+      head3a%ntrac=head%ntrac
+      head3a%nvcoord=head%nvcoord
+      head3a%icen2=head%icen2
+      head3a%iens=head%iens
+      head3a%idpp=head%idpp
+      head3a%idsl=head%idsl
+      head3a%idvc=head%idvc
+      head3a%idvm=head%idvm
+      head3a%idvt=head%idvt
+      head3a%idrun=head%idrun
+      head3a%idusr=head%idusr
+      head3a%pdryini=head%pdryini
+      head3a%ncldt=head%ncldt
+      head3a%ixgr=head%ixgr
+      head3a%ixga=head%ixga
+      head3a%reserved=0
+      iskip=iskip+nwrite
+      iwrite=head%lhead(3)
+!LLF+PM--
+      call byteswap(head3a%fhour,sigio_realkind,1)
+      call byteswap(head3a%idate,sigio_intkind,28)
+      call byteswap(head3a%pdryini,sigio_realkind,1)
+      call byteswap(head3a%ncldt,sigio_intkind,20)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,head3a)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(head3a%fhour,sigio_realkind,1)
+      call byteswap(head3a%idate,sigio_intkind,28)
+      call byteswap(head3a%pdryini,sigio_realkind,1)
+      call byteswap(head3a%ncldt,sigio_intkind,20)
+!LLF+PM==
+      iskip=iskip+nwrite
+      iwrite=head%lhead(4)
+!LLF+PM--
+      call byteswap(head%vcoord,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,head%vcoord)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(head%vcoord,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      iskip=iskip+nwrite
+      iwrite=head%lhead(5)
+      call bafrwritel(lu,iskip,iwrite,nwrite,head%cfvars)
+      if(nwrite.lt.iwrite) return
+!
+      if (mod(head%idvm/10,10) == 3) then
+        iskip=iskip+nwrite
+        iwrite=head%lhead(7)
+        call byteswap(head%cpi,sigio_realkind,iwrite/sigio_realkind)
+        call bafrwritel(lu,iskip,iwrite,nwrite,head%cpi)
+        if(nwrite.lt.iwrite) return
+        iskip=iskip+nwrite
+        iwrite=head%lhead(7)
+        call byteswap(head%ri,sigio_realkind,iwrite/sigio_realkind)
+        call bafrwritel(lu,iskip,iwrite,nwrite,head%ri)
+        if(nwrite.lt.iwrite) return
+      endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    else
+      iskip=0
+      iwrite=sigio_lhead1
+      call bafrwritel(lu,iskip,iwrite,nwrite,head%clabsig)
+      if(nwrite.lt.iwrite) return
+      head2%fhour=head%fhour 
+      head2%idate=head%idate 
+      head2%sisl=0
+      if(head%idvc.eq.2) then
+        if(head%nvcoord.eq.2.and.head%vcoord(1,2).eq.1.) then
+          head2%sisl(1:head%levs+1)=head%vcoord(1:head%levs+1,1)
+          head2%sisl(head%levs+2:2*head%levs+2)=head%vcoord(1:head%levs+1,2)
+        else
+          head2%sisl(1:head%levs+1)=head%ak(1:head%levs+1)
+          head2%sisl(head%levs+2:2*head%levs+2)=head%bk(1:head%levs+1)
+        endif
+      elseif(head%idvc.eq.0.or.head%idvc.eq.1) then
+        if(head%nvcoord.eq.1.and.head%vcoord(1,1).eq.1.) then
+          head2%sisl(1:head%levs+1)=head%vcoord(1:head%levs+1,1)
+          call sigio_modpr(1,1,head%levs,head%nvcoord,head%idvc,head%idsl,&
+                           head%vcoord,iret,ps=(/1./),&
+                           pm=head2%sisl(head%levs+2:2*head%levs+1))
+        else
+          head2%sisl(1:head%levs+1)=head%si(1:head%levs+1)
+          head2%sisl(head%levs+2:2*head%levs+1)=head%sl(1:head%levs)
+        endif
+      endif
+      head2%ext(1)=head%jcap
+      head2%ext(2)=head%levs
+      head2%ext(3)=head%itrun
+      head2%ext(4)=head%iorder
+      head2%ext(5)=head%irealf
+      head2%ext(6)=head%igen
+      head2%ext(7)=head%lonf
+      head2%ext(8)=head%latf
+      head2%ext(9)=head%lonb
+      head2%ext(10)=head%latb
+      head2%ext(11)=head%lonr
+      head2%ext(12)=head%latr
+      head2%ext(13)=head%ntrac
+      head2%ext(14)=head%icen2
+      head2%ext(15:16)=head%iens
+      head2%ext(17)=head%idpp
+      head2%ext(18)=head%idsl
+      head2%ext(19)=head%idvc
+      head2%ext(20)=head%idvm
+      head2%ext(21)=head%idvt
+      head2%ext(22)=head%idrun
+      head2%ext(23)=head%idusr
+      head2%ext(24)=head%pdryini
+      head2%ext(25)=head%ncldt
+      head2%ext(26:44)=0
+      iskip=iskip+nwrite
+      iwrite=1000
+!LLF+PM--
+      call byteswap(head2%fhour,sigio_realkind,1)
+      call byteswap(head2%idate,sigio_intkind,4)
+      call byteswap(head2%sisl,sigio_realkind,245)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,head2)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(head2%fhour,sigio_realkind,1)
+      call byteswap(head2%idate,sigio_intkind,4)
+      call byteswap(head2%sisl,sigio_realkind,245)
+!LLF+PM==
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    iret=0
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldats(head,dats,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    type(sigio_dats),intent(inout):: dats
+    integer(sigio_intkind),intent(out):: iret
+    integer nc,dim1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!   call sigio_axdats(dats,iret)
+    if(associated(dats%hs)) call sigio_axdats(dats,iret)
+    nc=(head%jcap+1)*(head%jcap+2)
+    dim1=nc
+    allocate(dats%hs(dim1),dats%ps(dim1),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdats(dats,iret)
+    implicit none
+    type(sigio_dats),intent(inout):: dats
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    deallocate(dats%hs,dats%ps,stat=iret)
+    nullify(dats%hs,dats%ps)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldatm(head,k1,k2,datm,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    integer(sigio_intkind),intent(in):: k1,k2
+    type(sigio_datm),intent(inout):: datm
+    integer(sigio_intkind),intent(out):: iret
+    integer nc,dim1,dim3q
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!   call sigio_axdatm(datm,iret)
+    if(associated(datm%t)) call sigio_axdatm(datm,iret)
+    iret=-3
+    if(k1.lt.1.or.k2.gt.head%levs) return
+    nc=(head%jcap+1)*(head%jcap+2)
+    dim1=nc
+    dim3q=head%ntrac
+    datm%k1=k1
+    datm%k2=k2
+    allocate(datm%t(dim1,k1:k2),datm%d(dim1,k1:k2),datm%z(dim1,k1:k2),&
+             datm%q(dim1,k1:k2,dim3q),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdatm(datm,iret)
+    implicit none
+    type(sigio_datm),intent(inout):: datm
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    datm%k1=0
+    datm%k2=0
+    deallocate(datm%t,datm%d,datm%z,datm%q,stat=iret)
+    nullify(datm%t,datm%d,datm%z,datm%q)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldati(head,i,dati,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    integer(sigio_intkind),intent(in):: i
+    type(sigio_dati),intent(inout):: dati
+    integer(sigio_intkind),intent(out):: iret
+    integer dim1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!   call sigio_axdati(dati,iret)
+    if(associated(dati%f)) call sigio_axdati(dati,iret)
+    iret=-3
+    if(i.lt.1.or.i.gt.head%ndata) return
+    dim1=head%ldata(i)/(4*head%irealf)
+    dati%i=i
+    allocate(dati%f(dim1),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdati(dati,iret)
+    implicit none
+    type(sigio_dati),intent(inout):: dati
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    dati%i=0
+    deallocate(dati%f,stat=iret)
+    nullify(dati%f)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdata(lu,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_data),intent(inout):: data
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,mdim1,mdim2,mdim3q
+    integer(8):: iskip,iread,nread
+    type(sigio_dbta):: dbta
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(data%hs,1),size(data%ps,1),&
+              size(data%t,1),size(data%d,1),size(data%z,1),&
+              size(data%q,1))
+    mdim2=min(size(data%t,2),size(data%d,2),size(data%z,2),&
+              size(data%q,2))
+    mdim3q=size(data%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,data%hs)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(data%hs,sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nread
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,data%ps)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(data%ps,sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,data%t(1,k))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%t(1,k),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      enddo
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,data%d(1,k))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%d(1,k),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,data%z(1,k))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%z(1,k),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          i=i+1
+          iskip=iskip+nread
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,data%q(1,k,n))
+          if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%q(1,k,n),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+        enddo
+      enddo
+      do n=1,head%nxgr
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,data%xgr(1,1,n))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%xgr(1,1,n),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      enddo
+      if(head%nxss.gt.0) then
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,data%xss)
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%xss,sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,data%xga(1,1,n))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(data%xga(1,1,n),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      enddo
+      endif
+    else
+      call sigio_aldbta(head,dbta,iret)
+      if(iret.ne.0) return
+      call sigio_rrdbta(lu,head,dbta,iret)
+      if(iret.ne.0) return
+      data%hs(:nc)=dbta%hs(:nc)
+      data%ps(:nc)=dbta%ps(:nc)
+      data%t(:nc,:head%levs)=dbta%t(:nc,:head%levs)
+      data%d(:nc,:head%levs)=dbta%d(:nc,:head%levs)
+      data%z(:nc,:head%levs)=dbta%z(:nc,:head%levs)
+      data%q(:nc,:head%levs,:head%ntrac)=dbta%q(:nc,:head%levs,:head%ntrac)
+      data%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       dbta%xgr(:head%lonb,:head%latb,:head%nxgr)
+      data%xss(:head%nxss)=dbta%xss(:head%nxss)
+      data%xga(:head%lonf,:head%latf,:head%nxga)=&
+       dbta%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_axdbta(dbta,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdata(lu,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_data),intent(in):: data
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,mdim1,mdim2,mdim3q
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_dbta):: dbta
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(data%hs,1),size(data%ps,1),&
+              size(data%t,1),size(data%d,1),size(data%z,1),&
+              size(data%q,1))
+    mdim2=min(size(data%t,2),size(data%d,2),size(data%z,2),&
+              size(data%q,2))
+    mdim3q=size(data%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(data%hs,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,data%hs)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(data%hs,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nwrite
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(data%ps,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,data%ps)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(data%ps,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(data%t(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,data%t(1,k))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(data%t(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      enddo
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(data%d(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,data%d(1,k))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(data%d(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(data%z(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,data%z(1,k))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(data%z(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          i=i+1
+          iskip=iskip+nwrite
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(data%q(1,k,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,data%q(1,k,n))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(data%q(1,k,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        enddo
+      enddo
+      do n=1,head%nxgr
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(data%xgr(1,1,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,data%xgr(1,1,n))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(data%xgr(1,1,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      enddo
+      if(head%nxss.gt.0) then
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(data%xss,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,data%xss)
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(data%xss,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(data%xga(1,1,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,data%xga(1,1,n))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(data%xga(1,1,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      enddo
+      endif
+    else
+      call sigio_aldbta(head,dbta,iret)
+      if(iret.ne.0) return
+      dbta%hs(:nc)=data%hs(:nc)
+      dbta%ps(:nc)=data%ps(:nc)
+      dbta%t(:nc,:head%levs)=data%t(:nc,:head%levs)
+      dbta%d(:nc,:head%levs)=data%d(:nc,:head%levs)
+      dbta%z(:nc,:head%levs)=data%z(:nc,:head%levs)
+      dbta%q(:nc,:head%levs,:head%ntrac)=data%q(:nc,:head%levs,:head%ntrac)
+      dbta%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       data%xgr(:head%lonb,:head%latb,:head%nxgr)
+      dbta%xss(:head%nxss)=data%xss(:head%nxss)
+      dbta%xga(:head%lonf,:head%latf,:head%nxga)=&
+       data%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_rwdbta(lu,head,dbta,iret)
+      if(iret.ne.0) return
+      call sigio_axdbta(dbta,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrohdca(lu,cfname,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_data),intent(inout):: data
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rropen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rrhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_aldata(head,data,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rrdata(lu,head,data,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwohdca(lu,cfname,head,data,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_data),intent(in):: data
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rwopen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rwhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rwdata(lu,head,data,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdats(lu,head,dats,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dats),intent(inout):: dats
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i
+    integer:: nc,mdim1
+    integer(8):: iskip,iread,nread
+    type(sigio_dbts):: dbts
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(dats%hs,1),size(dats%ps,1))
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dats%hs)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dats%hs,sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nread
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dats%ps)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dats%ps,sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+    else
+      call sigio_aldbts(head,dbts,iret)
+      if(iret.ne.0) return
+      call sigio_rrdbts(lu,head,dbts,iret)
+      if(iret.ne.0) return
+      dats%hs(:nc)=dbts%hs(:nc)
+      dats%ps(:nc)=dbts%ps(:nc)
+      call sigio_axdbts(dbts,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdats(lu,head,dats,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dats),intent(in):: dats
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i
+    integer:: nc,mdim1
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_dbts):: dbts
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(dats%hs,1),size(dats%ps,1))
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dats%hs,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dats%hs)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dats%hs,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nwrite
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dats%ps,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dats%ps)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dats%ps,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+    else
+      call sigio_aldbts(head,dbts,iret)
+      if(iret.ne.0) return
+      dbts%hs(:nc)=dats%hs(:nc)
+      dbts%ps(:nc)=dats%ps(:nc)
+      call sigio_rwdbts(lu,head,dbts,iret)
+      if(iret.ne.0) return
+      call sigio_axdbts(dbts,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdatm(lu,head,datm,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_datm),intent(inout):: datm
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,k1,k2,mdim1,ldim2,udim2,mdim3q
+    integer(8):: iskip,iread,nread
+    type(sigio_dbtm):: dbtm
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    k1=datm%k1
+    k2=datm%k2
+    mdim1=min(size(datm%t,1),size(datm%d,1),size(datm%z,1),&
+              size(datm%q,1))
+    ldim2=max(lbound(datm%t,2),lbound(datm%d,2),lbound(datm%z,2),&
+              lbound(datm%q,2))
+    udim2=min(ubound(datm%t,2),ubound(datm%d,2),ubound(datm%z,2),&
+              ubound(datm%q,2))
+    mdim3q=size(datm%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(k1.lt.1.or.k2.gt.head%levs.or.&
+       mdim1.lt.nc.or.&
+       ldim2.gt.k1.or.udim2.lt.k2.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      i=i+1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          i=i+1
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,datm%t(1,k))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(datm%t(1,k),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+          iskip=iskip+nread
+        endif
+      enddo
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,datm%d(1,k))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(datm%d(1,k),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+          iskip=iskip+nread
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,datm%z(1,k))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(datm%z(1,k),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+          iskip=iskip+nread
+        endif
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          if(k.lt.k1.or.k.gt.k2) then
+            i=i+1
+            call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          else
+            i=i+1
+            iread=head%ldata(i)
+            call bafrreadl(lu,iskip,iread,nread,datm%q(1,k,n))
+            if(nread.lt.iread) return
+!LLF+PM--
+            call byteswap(datm%q(1,k,n),sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+            iskip=iskip+nread
+          endif
+        enddo
+      enddo
+    else
+      call sigio_aldbtm(head,k1,k2,dbtm,iret)
+      if(iret.ne.0) return
+      call sigio_rrdbtm(lu,head,dbtm,iret)
+      if(iret.ne.0) return
+      datm%t(:nc,k1:k2)=dbtm%t(:nc,k1:k2)
+      datm%d(:nc,k1:k2)=dbtm%d(:nc,k1:k2)
+      datm%z(:nc,k1:k2)=dbtm%z(:nc,k1:k2)
+      datm%q(:nc,k1:k2,:head%ntrac)=dbtm%q(:nc,k1:k2,:head%ntrac)
+      call sigio_axdbtm(dbtm,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdatm(lu,head,datm,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_datm),intent(in):: datm
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,k1,k2,mdim1,ldim2,udim2,mdim3q
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_dbtm):: dbtm
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    k1=datm%k1
+    k2=datm%k2
+    mdim1=min(size(datm%t,1),size(datm%d,1),size(datm%z,1),&
+              size(datm%q,1))
+    ldim2=max(lbound(datm%t,2),lbound(datm%d,2),lbound(datm%z,2),&
+              lbound(datm%q,2))
+    udim2=min(ubound(datm%t,2),ubound(datm%d,2),ubound(datm%z,2),&
+              ubound(datm%q,2))
+    mdim3q=size(datm%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(k1.lt.1.or.k2.gt.head%levs.or.&
+       mdim1.lt.nc.or.&
+       ldim2.gt.k1.or.udim2.lt.k2.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      i=i+1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          i=i+1
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(datm%t(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,datm%t(1,k))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(datm%t(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          iskip=iskip+nwrite
+        endif
+      enddo
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(datm%d(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,datm%d(1,k))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(datm%d(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          iskip=iskip+nwrite
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(datm%z(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,datm%z(1,k))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(datm%z(1,k),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+          iskip=iskip+nwrite
+        endif
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          if(k.lt.k1.or.k.gt.k2) then
+            i=i+1
+            call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          else
+            i=i+1
+            iwrite=head%ldata(i)
+!LLF+PM--
+            call byteswap(datm%q(1,k,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+            call bafrwritel(lu,iskip,iwrite,nwrite,datm%q(1,k,n))
+            if(nwrite.lt.iwrite) return
+!LLF+PM--
+            call byteswap(datm%q(1,k,n),sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+            iskip=iskip+nwrite
+          endif
+        enddo
+      enddo
+    else
+      call sigio_aldbtm(head,k1,k2,dbtm,iret)
+      if(iret.ne.0) return
+      dbtm%t(:nc,k1:k2)=datm%t(:nc,k1:k2)
+      dbtm%d(:nc,k1:k2)=datm%d(:nc,k1:k2)
+      dbtm%z(:nc,k1:k2)=datm%z(:nc,k1:k2)
+      dbtm%q(:nc,k1:k2,:head%ntrac)=datm%q(:nc,k1:k2,:head%ntrac)
+      call sigio_rwdbtm(lu,head,dbtm,iret)
+      if(iret.ne.0) return
+      call sigio_axdbtm(dbtm,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdati(lu,head,dati,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dati),intent(inout):: dati
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: mdim1
+    integer:: mlen
+    integer(8):: iskip,iread,nread
+    type(sigio_dbti):: dbti
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    i=dati%i
+    mdim1=size(dati%f,1)
+    iret=-5
+    if(i.lt.1.or.i.gt.head%ndata) return
+    mlen=head%ldata(i)/(4*head%irealf)
+    if(mdim1.lt.mlen) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      do i=1,dati%i-1
+        call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      enddo
+      i=dati%i
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dati%f)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dati%f,sigio_realkind,iread/sigio_realkind)
+!LLF+PM==
+    else
+      i=dati%i
+      call sigio_aldbti(head,i,dbti,iret)
+      if(iret.ne.0) return
+      call sigio_rrdbti(lu,head,dbti,iret)
+      if(iret.ne.0) return
+      dati%f(:mlen)=dbti%f(:mlen)
+      call sigio_axdbti(dbti,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdati(lu,head,dati,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dati),intent(in):: dati
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: mdim1
+    integer:: mlen
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_dbti):: dbti
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    i=dati%i
+    mdim1=size(dati%f,1)
+    iret=-5
+    if(i.lt.1.or.i.gt.head%ndata) return
+    mlen=head%ldata(i)/(4*head%irealf)
+    if(mdim1.lt.mlen) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.ne.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      do i=1,dati%i-1
+        call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      enddo
+      i=dati%i
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dati%f,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dati%f)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dati%f,sigio_realkind,iwrite/sigio_realkind)
+!LLF+PM==
+      iret=0
+    else
+      i=dati%i
+      call sigio_aldbti(head,i,dbti,iret)
+      if(iret.ne.0) return
+      dbti%f(:mlen)=dati%f(:mlen)
+      call sigio_rwdbti(lu,head,dbti,iret)
+      if(iret.ne.0) return
+      call sigio_axdbti(dbti,iret)
+    endif
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldbts(head,dbts,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    type(sigio_dbts),intent(inout):: dbts
+    integer(sigio_intkind),intent(out):: iret
+    integer nc,dim1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!   call sigio_axdbts(dbts,iret)
+    if(associated(dbts%hs)) call sigio_axdbts(dbts,iret)
+    nc=(head%jcap+1)*(head%jcap+2)
+    dim1=nc
+    allocate(dbts%hs(dim1),dbts%ps(dim1),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdbts(dbts,iret)
+    implicit none
+    type(sigio_dbts),intent(inout):: dbts
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    deallocate(dbts%hs,dbts%ps,stat=iret)
+    nullify(dbts%hs,dbts%ps)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldbtm(head,k1,k2,dbtm,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    integer(sigio_intkind),intent(in):: k1,k2
+    type(sigio_dbtm),intent(inout):: dbtm
+    integer(sigio_intkind),intent(out):: iret
+    integer nc,dim1,dim3q
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!   call sigio_axdbtm(dbtm,iret)
+    if(associated(dbtm%t)) call sigio_axdbtm(dbtm,iret)
+    iret=-3
+    if(k1.lt.1.or.k2.gt.head%levs) return
+    nc=(head%jcap+1)*(head%jcap+2)
+    dim1=nc
+    dim3q=head%ntrac
+    dbtm%k1=k1
+    dbtm%k2=k2
+    allocate(dbtm%t(dim1,k1:k2),dbtm%d(dim1,k1:k2),dbtm%z(dim1,k1:k2),&
+             dbtm%q(dim1,k1:k2,dim3q),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdbtm(dbtm,iret)
+    implicit none
+    type(sigio_dbtm),intent(inout):: dbtm
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    dbtm%k1=0
+    dbtm%k2=0
+    deallocate(dbtm%t,dbtm%d,dbtm%z,dbtm%q,stat=iret)
+    nullify(dbtm%t,dbtm%d,dbtm%z,dbtm%q)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_aldbti(head,i,dbti,iret)
+    implicit none
+    type(sigio_head),intent(in):: head
+    integer(sigio_intkind),intent(in):: i
+    type(sigio_dbti),intent(inout):: dbti
+    integer(sigio_intkind),intent(out):: iret
+    integer dim1
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!   call sigio_axdbti(dbti,iret)
+    if(associated(dbti%f)) call sigio_axdbti(dbti,iret)
+    iret=-3
+    if(i.lt.1.or.i.gt.head%ndata) return
+    dim1=head%ldata(i)/(4*head%irealf)
+    dbti%i=i
+    allocate(dbti%f(dim1),stat=iret)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_axdbti(dbti,iret)
+    implicit none
+    type(sigio_dbti),intent(inout):: dbti
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    dbti%i=0
+    deallocate(dbti%f,stat=iret)
+    nullify(dbti%f)
+    if(iret.ne.0) iret=-3
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdbta(lu,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbta),intent(inout):: dbta
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,mdim1,mdim2,mdim3q
+    integer(8):: iskip,iread,nread
+    type(sigio_data):: data
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(dbta%hs,1),size(dbta%ps,1),&
+              size(dbta%t,1),size(dbta%d,1),size(dbta%z,1),&
+              size(dbta%q,1))
+    mdim2=min(size(dbta%t,2),size(dbta%d,2),size(dbta%z,2),&
+              size(dbta%q,2))
+    mdim3q=size(dbta%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dbta%hs)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dbta%hs,sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nread
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dbta%ps)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dbta%ps,sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,dbta%t(1,k))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(dbta%t(1,k),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      enddo
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,dbta%d(1,k))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(dbta%d(1,k),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,dbta%z(1,k))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(dbta%z(1,k),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          i=i+1
+          iskip=iskip+nread
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,dbta%q(1,k,n))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(dbta%q(1,k,n),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+        enddo
+      enddo
+      do n=1,head%nxgr
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,dbta%xgr(1,1,n))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(dbta%xgr(1,1,n),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      enddo
+      if(head%nxss.gt.0) then
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,dbta%xss)
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(dbta%xss,sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        i=i+1
+        iskip=iskip+nread
+        iread=head%ldata(i)
+        call bafrreadl(lu,iskip,iread,nread,dbta%xga(1,1,n))
+        if(nread.lt.iread) return
+!LLF+PM--
+        call byteswap(dbta%xga(1,1,n),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      enddo
+      endif
+    else
+      call sigio_aldata(head,data,iret)
+      if(iret.ne.0) return
+      call sigio_rrdata(lu,head,data,iret)
+      if(iret.ne.0) return
+      dbta%hs(:nc)=data%hs(:nc)
+      dbta%ps(:nc)=data%ps(:nc)
+      dbta%t(:nc,:head%levs)=data%t(:nc,:head%levs)
+      dbta%d(:nc,:head%levs)=data%d(:nc,:head%levs)
+      dbta%z(:nc,:head%levs)=data%z(:nc,:head%levs)
+      dbta%q(:nc,:head%levs,:head%ntrac)=data%q(:nc,:head%levs,:head%ntrac)
+      dbta%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       data%xgr(:head%lonb,:head%latb,:head%nxgr)
+      dbta%xss(:head%nxss)=data%xss(:head%nxss)
+      dbta%xga(:head%lonf,:head%latf,:head%nxga)=&
+       data%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_axdata(data,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdbta(lu,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbta),intent(in):: dbta
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,mdim1,mdim2,mdim3q
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_data):: data
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(dbta%hs,1),size(dbta%ps,1),&
+              size(dbta%t,1),size(dbta%d,1),size(dbta%z,1),&
+              size(dbta%q,1))
+    mdim2=min(size(dbta%t,2),size(dbta%d,2),size(dbta%z,2),&
+              size(dbta%q,2))
+    mdim3q=size(dbta%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc.or.&
+       mdim2.lt.head%levs.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dbta%hs,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dbta%hs)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dbta%hs,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nwrite
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dbta%ps,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dbta%ps)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dbta%ps,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(dbta%t(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,dbta%t(1,k))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(dbta%t(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      enddo
+      do k=1,head%levs
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(dbta%d(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,dbta%d(1,k))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(dbta%d(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(dbta%z(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,dbta%z(1,k))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(dbta%z(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          i=i+1
+          iskip=iskip+nwrite
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(dbta%q(1,k,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,dbta%q(1,k,n))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(dbta%q(1,k,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        enddo
+      enddo
+      do n=1,head%nxgr
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(dbta%xgr(1,1,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,dbta%xgr(1,1,n))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(dbta%xgr(1,1,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      enddo
+      if(head%nxss.gt.0) then
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(dbta%xss,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,dbta%xss)
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(dbta%xss,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      endif
+      if(head%nxga.gt.0) then
+      do n=1,head%nxga
+        i=i+1
+        iskip=iskip+nwrite
+        iwrite=head%ldata(i)
+!LLF+PM--
+        call byteswap(dbta%xga(1,1,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+        call bafrwritel(lu,iskip,iwrite,nwrite,dbta%xga(1,1,n))
+        if(nwrite.lt.iwrite) return
+!LLF+PM--
+        call byteswap(dbta%xga(1,1,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      enddo
+      endif
+    else
+      call sigio_aldata(head,data,iret)
+      if(iret.ne.0) return
+      data%hs(:nc)=dbta%hs(:nc)
+      data%ps(:nc)=dbta%ps(:nc)
+      data%t(:nc,:head%levs)=dbta%t(:nc,:head%levs)
+      data%d(:nc,:head%levs)=dbta%d(:nc,:head%levs)
+      data%z(:nc,:head%levs)=dbta%z(:nc,:head%levs)
+      data%q(:nc,:head%levs,:head%ntrac)=dbta%q(:nc,:head%levs,:head%ntrac)
+      data%xgr(:head%lonb,:head%latb,:head%nxgr)=&
+       dbta%xgr(:head%lonb,:head%latb,:head%nxgr)
+      data%xss(:head%nxss)=dbta%xss(:head%nxss)
+      data%xga(:head%lonf,:head%latf,:head%nxga)=&
+       dbta%xga(:head%lonf,:head%latf,:head%nxga)
+      call sigio_rwdata(lu,head,data,iret)
+      if(iret.ne.0) return
+      call sigio_axdata(data,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrohdcb(lu,cfname,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_dbta),intent(inout):: dbta
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rropen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rrhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_aldbta(head,dbta,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rrdbta(lu,head,dbta,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwohdcb(lu,cfname,head,dbta,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    character*(*),intent(in):: cfname
+    type(sigio_head),intent(inout):: head
+    type(sigio_dbta),intent(in):: dbta
+    integer(sigio_intkind),intent(out):: iret
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rwopen(lu,cfname,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rwhead(lu,head,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rwdbta(lu,head,dbta,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    call sigio_rclose(lu,iret)
+    if(iret.ne.0) return
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdbts(lu,head,dbts,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbts),intent(inout):: dbts
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i
+    integer:: nc,mdim1
+    integer(8):: iskip,iread,nread
+    type(sigio_dats):: dats
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(dbts%hs,1),size(dbts%ps,1))
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dbts%hs)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dbts%hs,sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nread
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dbts%ps)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dbts%ps,sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+    else
+      call sigio_aldats(head,dats,iret)
+      if(iret.ne.0) return
+      call sigio_rrdats(lu,head,dats,iret)
+      if(iret.ne.0) return
+      dbts%hs(:nc)=dats%hs(:nc)
+      dbts%ps(:nc)=dats%ps(:nc)
+      call sigio_axdats(dats,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdbts(lu,head,dbts,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbts),intent(in):: dbts
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i
+    integer:: nc,mdim1
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_dats):: dats
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    mdim1=min(size(dbts%hs,1),size(dbts%ps,1))
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(mdim1.lt.nc) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dbts%hs,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dbts%hs)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dbts%hs,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      i=i+1
+      iskip=iskip+nwrite
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dbts%ps,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dbts%ps)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dbts%ps,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+    else
+      call sigio_aldats(head,dats,iret)
+      if(iret.ne.0) return
+      dats%hs(:nc)=dbts%hs(:nc)
+      dats%ps(:nc)=dbts%ps(:nc)
+      call sigio_rwdats(lu,head,dats,iret)
+      if(iret.ne.0) return
+      call sigio_axdats(dats,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdbtm(lu,head,dbtm,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbtm),intent(inout):: dbtm
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,k1,k2,mdim1,ldim2,udim2,mdim3q
+    integer(8):: iskip,iread,nread
+    type(sigio_datm):: datm
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    k1=dbtm%k1
+    k2=dbtm%k2
+    mdim1=min(size(dbtm%t,1),size(dbtm%d,1),size(dbtm%z,1),&
+              size(dbtm%q,1))
+    ldim2=max(lbound(dbtm%t,2),lbound(dbtm%d,2),lbound(dbtm%z,2),&
+              lbound(dbtm%q,2))
+    udim2=min(ubound(dbtm%t,2),ubound(dbtm%d,2),ubound(dbtm%z,2),&
+              ubound(dbtm%q,2))
+    mdim3q=size(dbtm%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(k1.lt.1.or.k2.gt.head%levs.or.&
+       mdim1.lt.nc.or.&
+       ldim2.gt.k1.or.udim2.lt.k2.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      i=i+1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          i=i+1
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,dbtm%t(1,k))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(dbtm%t(1,k),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+          iskip=iskip+nread
+        endif
+      enddo
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,dbtm%d(1,k))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(dbtm%d(1,k),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+          iskip=iskip+nread
+          iread=head%ldata(i)
+          call bafrreadl(lu,iskip,iread,nread,dbtm%z(1,k))
+          if(nread.lt.iread) return
+!LLF+PM--
+          call byteswap(dbtm%z(1,k),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+          iskip=iskip+nread
+        endif
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          if(k.lt.k1.or.k.gt.k2) then
+            i=i+1
+            call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          else
+            i=i+1
+            iread=head%ldata(i)
+            call bafrreadl(lu,iskip,iread,nread,dbtm%q(1,k,n))
+            if(nread.lt.iread) return
+!LLF+PM--
+            call byteswap(dbtm%q(1,k,n),sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+            iskip=iskip+nread
+          endif
+        enddo
+      enddo
+    else
+      call sigio_aldatm(head,k1,k2,datm,iret)
+      if(iret.ne.0) return
+      call sigio_rrdatm(lu,head,datm,iret)
+      if(iret.ne.0) return
+      dbtm%t(:nc,k1:k2)=datm%t(:nc,k1:k2)
+      dbtm%d(:nc,k1:k2)=datm%d(:nc,k1:k2)
+      dbtm%z(:nc,k1:k2)=datm%z(:nc,k1:k2)
+      dbtm%q(:nc,k1:k2,:head%ntrac)=datm%q(:nc,k1:k2,:head%ntrac)
+      call sigio_axdatm(datm,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdbtm(lu,head,dbtm,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbtm),intent(in):: dbtm
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: nc,k1,k2,mdim1,ldim2,udim2,mdim3q
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_datm):: datm
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    k1=dbtm%k1
+    k2=dbtm%k2
+    mdim1=min(size(dbtm%t,1),size(dbtm%d,1),size(dbtm%z,1),&
+              size(dbtm%q,1))
+    ldim2=max(lbound(dbtm%t,2),lbound(dbtm%d,2),lbound(dbtm%z,2),&
+              lbound(dbtm%q,2))
+    udim2=min(ubound(dbtm%t,2),ubound(dbtm%d,2),ubound(dbtm%z,2),&
+              ubound(dbtm%q,2))
+    mdim3q=size(dbtm%q,3)
+    nc=(head%jcap+1)*(head%jcap+2)
+    iret=-5
+    if(k1.lt.1.or.k2.gt.head%levs.or.&
+       mdim1.lt.nc.or.&
+       ldim2.gt.k1.or.udim2.lt.k2.or.&
+       mdim3q.lt.head%ntrac) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      i=1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      i=i+1
+      call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          i=i+1
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(dbtm%t(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,dbtm%t(1,k))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(dbtm%t(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          iskip=iskip+nwrite
+        endif
+      enddo
+      do k=1,head%levs
+        if(k.lt.k1.or.k.gt.k2) then
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          i=i+1
+          call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+        else
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(dbtm%d(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,dbtm%d(1,k))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(dbtm%d(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          iskip=iskip+nwrite
+          iwrite=head%ldata(i)
+!LLF+PM--
+          call byteswap(dbtm%z(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          call bafrwritel(lu,iskip,iwrite,nwrite,dbtm%z(1,k))
+          if(nwrite.lt.iwrite) return
+!LLF+PM--
+          call byteswap(dbtm%z(1,k),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+          iskip=iskip+nwrite
+        endif
+      enddo
+      do n=1,head%ntrac
+        do k=1,head%levs
+          if(k.lt.k1.or.k.gt.k2) then
+            i=i+1
+            call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+          else
+            i=i+1
+            iwrite=head%ldata(i)
+!LLF+PM--
+            call byteswap(dbtm%q(1,k,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+            call bafrwritel(lu,iskip,iwrite,nwrite,dbtm%q(1,k,n))
+            if(nwrite.lt.iwrite) return
+!LLF+PM--
+            call byteswap(dbtm%q(1,k,n),sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+            iskip=iskip+nwrite
+          endif
+        enddo
+      enddo
+    else
+      call sigio_aldatm(head,k1,k2,datm,iret)
+      if(iret.ne.0) return
+      datm%t(:nc,k1:k2)=dbtm%t(:nc,k1:k2)
+      datm%d(:nc,k1:k2)=dbtm%d(:nc,k1:k2)
+      datm%z(:nc,k1:k2)=dbtm%z(:nc,k1:k2)
+      datm%q(:nc,k1:k2,:head%ntrac)=dbtm%q(:nc,k1:k2,:head%ntrac)
+      call sigio_rwdatm(lu,head,datm,iret)
+      if(iret.ne.0) return
+      call sigio_axdatm(datm,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rrdbti(lu,head,dbti,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbti),intent(inout):: dbti
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: mdim1
+    integer:: mlen
+    integer(8):: iskip,iread,nread
+    type(sigio_dati):: dati
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    i=dbti%i
+    mdim1=size(dbti%f,1)
+    iret=-5
+    if(i.lt.1.or.i.gt.head%ndata) return
+    mlen=head%ldata(i)/(4*head%irealf)
+    if(mdim1.lt.mlen) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      do i=1,dbti%i-1
+        call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      enddo
+      i=dbti%i
+      iread=head%ldata(i)
+      call bafrreadl(lu,iskip,iread,nread,dbti%f)
+      if(nread.lt.iread) return
+!LLF+PM--
+      call byteswap(dbti%f,sigio_dblekind,iread/sigio_dblekind)
+!LLF+PM==
+    else
+      i=dbti%i
+      call sigio_aldati(head,i,dati,iret)
+      if(iret.ne.0) return
+      call sigio_rrdati(lu,head,dati,iret)
+      if(iret.ne.0) return
+      dbti%f(:mlen)=dati%f(:mlen)
+      call sigio_axdati(dati,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+  subroutine sigio_rwdbti(lu,head,dbti,iret)
+    implicit none
+    integer(sigio_intkind),intent(in):: lu
+    type(sigio_head),intent(in):: head
+    type(sigio_dbti),intent(in):: dbti
+    integer(sigio_intkind),intent(out):: iret
+    integer:: i,k,n
+    integer:: mdim1
+    integer:: mlen
+    integer(8):: iskip,iwrite,nwrite
+    type(sigio_dati):: dati
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    i=dbti%i
+    mdim1=size(dbti%f,1)
+    iret=-5
+    if(i.lt.1.or.i.gt.head%ndata) return
+    mlen=head%ldata(i)/(4*head%irealf)
+    if(mdim1.lt.mlen) return
+    iret=-4
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    if(head%irealf.eq.2) then
+      iskip=0
+      do i=1,head%nhead
+        call bafrindexl(0,iskip,int(head%lhead(i),8),iskip)
+      enddo
+      do i=1,dbti%i-1
+        call bafrindexl(0,iskip,int(head%ldata(i),8),iskip)
+      enddo
+      i=dbti%i
+      iwrite=head%ldata(i)
+!LLF+PM--
+      call byteswap(dbti%f,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+      call bafrwritel(lu,iskip,iwrite,nwrite,dbti%f)
+      if(nwrite.lt.iwrite) return
+!LLF+PM--
+      call byteswap(dbti%f,sigio_dblekind,iwrite/sigio_dblekind)
+!LLF+PM==
+    else
+      i=dbti%i
+      call sigio_aldati(head,i,dati,iret)
+      if(iret.ne.0) return
+      dati%f(:mlen)=dbti%f(:mlen)
+      call sigio_rwdati(lu,head,dati,iret)
+      if(iret.ne.0) return
+      call sigio_axdati(dati,iret)
+    endif
+    iret=0
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+  end subroutine
+!-------------------------------------------------------------------------------
+end module
