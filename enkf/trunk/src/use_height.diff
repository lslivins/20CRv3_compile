--- params.f90.orig	2013-03-12 09:02:46.851492000 -0700
+++ params.f90	2013-03-12 09:03:16.974083440 -0700
@@ -49,6 +49,7 @@
 integer,public :: nhr_anal=6
 character(len=2), public :: charfhr_anal
 logical, public :: iau=.false. 
+logical, public :: use_height=.false. 
 character(len=10), public ::  datestring
 character(len=500),public :: datapath
 character(len=20), public, dimension(nsatmax_rad) ::sattypes_rad, dsis
--- gridio.F90.orig	2013-03-12 09:04:24.980692000 -0700
+++ gridio.F90	2013-03-12 09:19:21.156868489 -0700
@@ -30,7 +30,7 @@
 !
 !$$$
  use constants, only: zero,one,cp,rd,grav,constants_initialized,zero
- use params, only: nlons,nlats,ndim,reducedgrid,nvars,nlevs,pseudo_rh, &
+ use params, only: nlons,nlats,ndim,reducedgrid,nvars,nlevs,pseudo_rh,use_height, &
                    cliptracers,nlons,nlats,datestring,datapath,massbal_adjust,charfhr_anal,iau
  use kinds, only: i_kind,r_double,r_kind,r_single
  use gridinfo, only: sighead,npts ! sighead saved in gridinfo. This means gridinfo must be called first!
@@ -55,10 +55,10 @@
 
   real(r_kind) kap,kapr,kap1
 
-  real(r_kind), allocatable, dimension(:,:) :: vmassdiv,pressi,pslg
+  real(r_kind), allocatable, dimension(:,:) :: vmassdiv,pressi,pslg,zg
   real(r_kind), dimension(nlons*nlats) :: ug,vg
   real(r_kind), dimension(ndimspec) :: vrtspec,divspec
-  real(r_kind), allocatable, dimension(:) :: psg,pstend,ak,bk
+  real(r_kind), allocatable, dimension(:) :: psg,pstend,ak,bk,zs
   type(sigio_data) sigdata
 
 
@@ -203,6 +203,27 @@
   else
      qsat = 1._r_double
   end if
+
+! compute z (geopot height) on interfaces, given 
+! pint (interface pressure in hPa),
+! pl (pressure at mid-layers in hPa), tv (virtual temp at mid-layers) and
+! zs (surface orog). 
+! z does not include surface height (k=1 is 1st level, k=nlevs is model top)
+! uses hydrostatic eqn d(phi)/d(pi) = -thetav, where phi is geopot. height,
+! pi is exner function and thetav is virtual potential temp.
+  if (use_height) then
+     allocate(zs(npts),zg(npts,nlevs))
+     ! surface orog
+     call sptez_s(sigdata%hs,ug,1)
+     if (reducedgrid) then
+        call regtoreduced(ug,zs)
+     else
+        zs = ug
+     endif
+     call temptoz(npts,nlevs,pressi,pslg,zs,grdin(:,2*nlevs+1:3*nlevs),zg)
+     grdin(:,2*nlevs+1:3*nlevs) = zg
+     deallocate(zs,zg)
+  end if
   
   deallocate(pressi,pslg)
   deallocate(psg,pstend,ak,bk)
@@ -217,10 +238,10 @@
   character(len=500):: filename
   integer, intent(in) :: nanal
   real(r_kind), dimension(npts,ndim), intent(inout) :: grdin
-  real(r_kind), allocatable, dimension(:,:) :: vmassdiv,pressi
+  real(r_kind), allocatable, dimension(:,:) :: vmassdiv,pressi,tvg,pslg
   real(r_kind), allocatable, dimension(:,:) :: vmassdivinc
   real(r_kind), allocatable,dimension(:) :: psg,pstend1,pstend2,pstendfg,vmass,&
-                                            ak,bk
+                                            zs,ak,bk
   real(r_kind), dimension(nlons*nlats) :: ug,vg,uginc,vginc,psfg
   real(r_kind), dimension(ndimspec) :: vrtspec,divspec
   integer iadate(4)
@@ -339,6 +360,47 @@
   call sptez_s(divspec,vg,-1)
   sigdata%ps = divspec
 
+  ! convert geopot. height increment to virt. temp increment is use_height is true.
+  if (use_height) then
+     allocate(zs(npts),tvg(npts,nlevs),pslg(npts,nlevs))
+     ug = 10._r_kind*exp(vg)
+     if (reducedgrid) then
+        call regtoreduced(ug,psg)
+     else
+        psg = ug
+     endif
+     if (sighead%idvc .eq. 0) then ! sigma coordinate, old file format.
+         ak = zero
+         bk = sighead%si(1:nlevs+1)
+     else if (sighead%idvc == 1) then ! sigma coordinate
+         ak = zero
+         bk = sighead%vcoord(1:nlevs+1,2)
+     else if (sighead%idvc == 2 .or. sighead%idvc == 3) then ! hybrid coordinate
+         bk = sighead%vcoord(1:nlevs+1,2) 
+         ak = 0.01*sighead%vcoord(1:nlevs+1,1)  ! convert to mb
+     else
+         print *,'unknown vertical coordinate type',sighead%idvc
+         call stop2(23)
+     end if
+     !==> pressure at interfaces.
+     do k=1,nlevs+1
+        pressi(:,k)=ak(k)+bk(k)*psg
+     enddo
+     ! compute saturation q.
+     do k=1,nlevs
+       ! layer pressure from phillips vertical interolation
+       pslg(:,k) = ((pressi(:,k)**kap1-pressi(:,k+1)**kap1)/&
+                   (kap1*(pressi(:,k)-pressi(:,k+1))))**kapr
+     end do
+     ! surface orog zero, since we're dealing with increments.
+     zs = zero
+     if (nproc .eq. 0) print *,'min/max height increment ens. mem.',nanal,minval(grdin(:,2*nlevs+1:3*nlevs)),maxval(grdin(:,2*nlevs+1:3*nlevs))
+     call ztotemp(npts,nlevs,pressi,pslg,zs,tvg,grdin(:,2*nlevs+1:3*nlevs))
+     if (nproc .eq. 0) print *,'min/max tv increment ens. mem.',nanal,minval(tvg),maxval(tvg)
+     grdin(:,2*nlevs+1:3*nlevs) = tvg ! virt temp increment
+     deallocate(zs,tvg,pslg)
+  end if
+
   if (massbal_adjust) then
 
      if (sighead%idvc .eq. 0) then ! sigma coordinate, old file format.
@@ -527,6 +589,72 @@
 
  end subroutine writegriddata
 
+ subroutine temptoz(npts,nlevs,pint,pl,zs,tv,z)
+! compute z (geopot height) on interfaces, given 
+! pint (interface pressure in hPa),
+! pl (pressure at mid-layers in hPa), tv (virtual temp at mid-layers) and
+! zs (surface orog). rd,cp,grav are gas constant, specific heat and gravity.
+! z does not include surface height (k=1 is 1st level, k=nlevs is model top)
+! uses hydrostatic eqn d(phi)/d(pi) = -thetav, where phi is geopot. height,
+! pi is exner function and thetav is virtual potential temp.
+  implicit none
+  integer, intent(in) :: npts,nlevs
+  real(r_kind), dimension(npts, nlevs) :: thetav,pil
+  real(r_kind), dimension(npts, nlevs+1) :: pii
+  real(r_kind), intent(in), dimension(npts,nlevs) :: tv,pl
+  real(r_kind), intent(in), dimension(npts,nlevs+1) :: pint
+  real(r_kind), intent(out), dimension(npts,nlevs) :: z
+  real(r_kind), intent(in), dimension(npts) :: zs
+  integer n,k
+  real dz
+ 
+  pii = cp*(pint/1000._r_kind)**(rd/cp)
+  pil = cp*(pl/1000._r_kind)**(rd/cp)
+  thetav = cp*tv/pil
+  do n=1,npts
+     dz = -thetav(n,1) * (pii(n,2)-pii(n,1))
+     z(n,1) = grav*zs(n) + dz
+     do k=3,nlevs+1
+        dz = -thetav(n,k-1) * (pii(n,k)-pii(n,k-1))
+        z(n,k-1) = z(n,k-2) + dz
+     end do
+  end do
+  z = z/grav
+ 
+ end subroutine temptoz
+
+ subroutine ztotemp(npts,nlevs,pint,pl,zs,tv,z)
+! compute virtual temp (tv) on mid-layers, given 
+! pint (interface pressure in hPa),
+! pl (pressure at mid-layers in hPa), z (z at interfaces) and
+! zs (surface orog). rd,cp.grav are  gas constant, specific heat and gravity.
+! z should not include surface height (k=1 is 1st level, k=nlevs is model top)
+! uses hydrostatic eqn d(phi)/d(pi) = -thetav, where phi is geopot. height,
+! pi is exner function and thetav is virtual potential temp.
+  implicit none
+  integer, intent(in) :: npts,nlevs
+  real(r_kind), dimension(npts, nlevs) :: thetav,pil
+  real(r_kind), dimension(npts, nlevs+1) :: pii
+  real(r_kind), intent(out), dimension(npts,nlevs) :: tv
+  real(r_kind), intent(in), dimension(npts,nlevs+1) :: pint
+  real(r_kind), intent(in), dimension(npts,nlevs) :: z,pl
+  real(r_kind), intent(in), dimension(npts) :: zs
+  integer n,k
+  real(r_kind) dz
+
+  pii = cp*(pint/1000._r_kind)**(rd/cp)
+  pil = cp*(pl/1000._r_kind)**(rd/cp)
+  do n=1,npts
+     dz = grav*(z(n,1) - zs(n))
+     thetav(n,1) = -dz/(pii(n,2)-pii(n,1))
+     do k=3,nlevs+1
+        dz = grav*(z(n,k-1) - z(n,k-2))
+        thetav(n,k-1) = -dz/(pii(n,k)-pii(n,k-1))
+     end do
+  end do
+  tv = thetav*pil/cp
+ end subroutine ztotemp
+
  end module gridio
 #endif
 #ifdef WRF
