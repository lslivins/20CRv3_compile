#!/bin/csh

# max number of cores for each global_postgp instance.
set nprocs_group_max=12

setenv FHZER $ANALINC
set FCSTVARS1=$FCSTVARS
unsetenv FCSTVARS

setenv VERBOSE YES
setenv mpitasks `expr $mpitasks \* $nanals`
setenv FHMAX_save $FHMAX
if ($iau == ".true.") then
   setenv FHDFI 0
   setenv FHROT $FHMIN
   setenv FHMAX `expr $FHMAX_save \+ $ANALINC`
   setenv SIGI ${datapath2}/sfg_${analdate}_fhr03
   ln -fs ${datapath2}/sfg_${analdate}_fhr03_mem001 ${SIGI}
   setenv SFCI ${datapath2}/sfcanl_${analdate}_fhr03
   ln -fs ${datapath2}/sfcanl_${analdate}_fhr03_mem001 ${SFCI}
   set charnanal='mem'
   if ($iaufhrs == "3,6,9") then
     set iaufiles_fg="'${datapath2}/sfg_${analdate}_fhr03_${charnanal}','${datapath2}/sfg_${analdate}_fhr06_${charnanal}','${datapath2}/sfg_${analdate}_fhr09_${charnanal}'"
     set iaufiles_anl="'${datapath2}/sanl_${analdate}_fhr03_${charnanal}','${datapath2}/sanl_${analdate}_fhr06_${charnanal}','${datapath2}/sanl_${analdate}_fhr09_${charnanal}'"
   else
     echo "iaufhrs=3,6,9 expected, got $iaufhrs"
   endif
   setenv FCSTVARS "${FCSTVARS1},iau=${iau},iaufhrs=${iaufhrs},iau_delthrs=${iau_delthrs},iaufiles_fg=${iaufiles_fg},iaufiles_anl=${iaufiles_anl}"
else
   setenv FCSTVARS $FCSTVARS1
   setenv SIGI ${datapath2}/sanl_${analdate}
   ln -fs ${datapath2}/sanl_${analdate}_mem001 ${SIGI}
   setenv SFCI ${datapath2}/sfcanl_${analdate}
   ln -fs ${datapath2}/sfcanl_${analdate}_mem001 ${SFCI}
endif
setenv ENS_NUM $nanals
set mem_names="_01"
set nmem=1
while ($nmem <= $ENS_NUM)
 set mn=`printf %02i $nmem`
 ln -fs ${SIGI}_mem0${mn} ${SIGI}_${mn}
 ln -fs ${SFCI}_mem0${mn} ${SFCI}_${mn}
 @ nmem = $nmem + 1
 set mem_names="${mem_names} _${mn}"
end
setenv MEMBER_NAMES "$mem_names"
setenv DATOUT ${datapath}${analdatep1}
setenv SIGO $DATOUT/sfg_${analdatep1}_fhr'${FH}${MN}'
setenv SFCO $DATOUT/bfg_${analdatep1}_fhr'${FH}${MN}'
setenv FLXO $DATOUT/sflxgrb_${analdatep1}_fhr'${FH}${MN}'
setenv LOGO /dev/null
setenv D3DO /dev/null
setenv G3DO /dev/null
setenv NSSTO /dev/null
setenv DATA $DATOUT/genstmp$$
mkdir -p $DATA

sh ${enkfscripts}/run_gefs >&! ${current_logdir}/run_gefs.out

/bin/rm -rf $DATA

ls -l $DATOUT/sfg_${analdatep1}_fhr*_01
ls -l $DATOUT/bfg_${analdatep1}_fhr*_01
ls -l $DATOUT/sflxgrb_${analdatep1}_fhr*_01

date
# rename output files.
if ($iau == '.true.') then
   set FH=$ANALINC
else
   set FH=0
endif
while ($FH <= $FHMAX) 
set charhr=`printf %02i $FH`
set nmem=1
while ($nmem <= $ENS_NUM)
 set MN=`printf %02i $nmem`
 set charnanal="mem`printf %03i $nmem`"
 /bin/mv -f $DATOUT/sfg_${analdatep1}_fhr${charhr}_${MN} $DATOUT/sfg_${analdatep1}_fhr${charhr}_${charnanal}
 /bin/mv -f $DATOUT/bfg_${analdatep1}_fhr${charhr}_${MN} $DATOUT/bfg_${analdatep1}_fhr${charhr}_${charnanal}
 /bin/mv -f $DATOUT/sflxgrb_${analdatep1}_fhr${charhr}_${MN} $DATOUT/sflxgrb_${analdatep1}_fhr${charhr}_${charnanal}
 @ nmem = $nmem + 1
end
@ FH = $FH + $FHOUT
end

if ($POSTPROC == 'YES') then
echo "starting postprocessing at `date`"
# do global_postgp (for 6h forecast and anal)
setenv DATA1 "${datapath2}/postgp1tmp.$$"
setenv DATA2 "${datapath2}/postgp2tmp.$$"
setenv DATA3 "${datapath2}/postgp3tmp.$$"
mkdir $DATA1
mkdir $DATA2
mkdir $DATA3
set nanal=1
set analdate_p3 = `${incdate} $analdate 3`
while ($nanal <= $nanals)
    set charnanal=`printf %02i $nanal`
    set charnanal3="mem`printf %03i $nanal`"

    setenv SIGINP1 ${datapathp1}/sfg_${analdatep1}_fhr06_${charnanal3}
    setenv FLXINP1 ${datapathp1}/sflxgrb_${analdatep1}_fhr06_${charnanal3}
    setenv PGBOUT1 ${datapath2}/pgrbanl_${analdate}_${charnanal3}

    setenv SIGINP2 ${datapathp1}/sfg_${analdatep1}_fhr09_${charnanal3}
    setenv FLXINP2 ${datapathp1}/sflxgrb_${analdatep1}_fhr09_${charnanal3}
    setenv PGBOUT2 ${datapath2}/pgrbanl_${analdate_p3}_${charnanal3}

    setenv SIGINP3 ${datapathp1}/sfg_${analdatep1}_fhr12_${charnanal3}
    setenv FLXINP3 ${datapathp1}/sflxgrb_${analdatep1}_fhr12_${charnanal3}
    setenv PGBOUT3 ${datapathp1}/pgrbfg_${analdatep1}_fhr06_${charnanal3}

cat <<EOF >! $DATA1/global_postgp.nml.$charnanal
 &NAMPGB
  DDSIG="$SIGINP1",
  DDFLX="$FLXINP1",
  DDPGB="$PGBOUT1",
  IO=$IO, JO=$JO, IGEN=82,
  $POSTGPVARS
EOF
cat $POSTGPLIST >> $DATA1/global_postgp.nml.$charnanal
cat <<EOF >> $DATA1/global_postgp.nml.$charnanal
 /
EOF
if ($nanal == 1) cat  $DATA1/global_postgp.nml.$charnanal
cat <<EOF >! $DATA2/global_postgp.nml.$charnanal
 &NAMPGB
  DDSIG="$SIGINP2",
  DDFLX="$FLXINP2",
  DDPGB="$PGBOUT2",
  IO=$IO, JO=$JO, IGEN=82,
  $POSTGPVARS
EOF
cat $POSTGPLIST >> $DATA2/global_postgp.nml.$charnanal
cat <<EOF >> $DATA2/global_postgp.nml.$charnanal
 /
EOF
if ($nanal == 1) cat  $DATA2/global_postgp.nml.$charnanal
cat <<EOF >! $DATA3/global_postgp.nml.$charnanal
 &NAMPGB
  DDSIG="$SIGINP3",
  DDFLX="$FLXINP3",
  DDPGB="$PGBOUT3",
  IO=$IO, JO=$JO, IGEN=82,
  $POSTGPVARS
EOF
cat $POSTGPLIST >> $DATA3/global_postgp.nml.$charnanal
cat <<EOF >> $DATA3/global_postgp.nml.$charnanal
 /
EOF
if ($nanal == 1) cat  $DATA3/global_postgp.nml.$charnanal
# add global_postgp steps.
@ nanal = $nanal + 1
end

# go to temp dir 1, run global_postgpp
cd $DATA1
setenv nprocs_group $fg_proc
if ($nprocs_group > $nprocs_group_max) then
 setenv nprocs_group $nprocs_group_max
endif
setenv nprocs `expr $nprocs_group \* $nanals`
set nhostsover3=`expr $nhosts \/ 3`
# if there are enough cores, run both at the same time.
if ($nprocs > $nhostsover3) then
aprun -n $nprocs ${EXECGLOBAL}/global_postgpp
else
echo "running global_postgpp in background ..."
aprun -n $nprocs ${EXECGLOBAL}/global_postgpp &
endif

# go to temp dir 2, run global_postgpp
cd $DATA2
if ($nprocs > $nhostsover3) then
aprun -n $nprocs ${EXECGLOBAL}/global_postgpp
else
echo "running global_postgpp in background ..."
aprun -n $nprocs ${EXECGLOBAL}/global_postgpp &
endif

# go to temp dir 2, run global_postgpp
cd $DATA3
if ($nprocs > $nhostsover3) then
aprun -n $nprocs ${EXECGLOBAL}/global_postgpp
else
echo "running global_postgpp in background ..."
aprun -n $nprocs ${EXECGLOBAL}/global_postgpp &
endif

wait 

cd $DATA1
# print the redirected standard output for each group back to the standard output
@ gindex = 1
#while ($gindex <= $nanals)
setenv index `printf "%02u" $gindex`
cat stdoutfile.$index 
#@ gindex = ($gindex + 1)
#end

cd $DATA2
# print the redirected standard output for each group back to the standard output
@ gindex = 1
#while ($gindex <= $nanals)
setenv index `printf "%02u" $gindex`
cat stdoutfile.$index 
#@ gindex = ($gindex + 1)
#end

cd $DATA3
# print the redirected standard output for each group back to the standard output
@ gindex = 1
#while ($gindex <= $nanals)
setenv index `printf "%02u" $gindex`
cat stdoutfile.$index 
#@ gindex = ($gindex + 1)
#end

cd $datapath2
/bin/rm -rf $DATA1
/bin/rm -rf $DATA2
/bin/rm -rf $DATA3
/bin/rm -rf ${datapath2}/postgp*tmp*
echo "done postprocessing at `date`"
endif

# change dates in files.
ls -l ${datapathp1}/sfg_${analdatep1}*mem001
ls -l ${datapathp1}/bfg_${analdatep1}*mem001
ls -l ${datapathp1}/sflxgrb_${analdatep1}*mem001
date

if ($iau ==  '.true.') then
   set ncount = 0
   set fh=$ANALINC
   while ($fh <= $FHMAX)
       @ fh2 = $fh - $ANALINC
       set charhr="fhr`printf %02i $fh`"
       set charhr2="fhr`printf %02i $fh2`"
       aprun -n $nanals -N $mpitaskspernode  ${EXECGLOBAL}/chgdatesigp.x ${datapathp1} sfg_${analdatep1}_${charhr}  ${nanals} ${analdate} $fh2 sfg_${analdatep1}_${charhr2} &
       @ ncount = $ncount + 1
       aprun -n $nanals -N $mpitaskspernode  ${EXECGLOBAL}/chgdatesfcp.x ${datapathp1} bfg_${analdatep1}_${charhr}  ${nanals} ${analdate} $fh2 bfg_${analdatep1}_${charhr2} &
       @ ncount = $ncount + 1
       @ fh = $fh + $FHOUT
       if ($ncount == 4) then
         wait
         set ncount=0
       endif
   end
   set fh=$ANALINC
   while ($fh <= $FHMAX)
       @ fh2 = $fh - $ANALINC
       set charhr="fhr`printf %02i $fh`"
       set charhr2="fhr`printf %02i $fh2`"
       set nanal=1
       while ($nanal <= $nanals)
          set charnanal="mem`printf %03i $nanal`"
          #if ($fh2 == 0) then
          #   # overwrite sanl and sfcanl files with forecast at end of IAU period
          #   /bin/cp -f ${datapathp1}/sfg_${analdatep1}_${charhr2}_${charnanal} ${datapath2}/sanl_${analdate}_${charnanal} 
          #   /bin/cp -f ${datapathp1}/bfg_${analdatep1}_${charhr2}_${charnanal} ${datapath2}/sfcanl_${analdate}_${charnanal} 
          #endif
          /bin/mv -f ${datapathp1}/sflxgrb_${analdatep1}_${charhr}_${charnanal} ${datapathp1}/sflxgrb_${analdatep1}_${charhr2}_${charnanal} 
          @ nanal = $nanal + 1
       end
       @ fh = $fh + $FHOUT
   end

   # create new sfcanl*ensmean and sanl*ensmean files
   #aprun -n 1 -N 1 ${EXECGLOBAL}/getsfcensmeanp.x ${datapath}/${analdate}/ sfcanl_${analdate}_ensmean sfcanl_${analdate} ${nanals}  &
   #aprun -n $nanals -N $enkf_taskspernode ${EXECGLOBAL}/getsfcensmeanp.x ${datapath}/${analdate}/ sfcanl_${analdate}_ensmean sfcanl_${analdate} ${nanals}  &
   #aprun -n $nanals -N $enkf_taskspernode ${EXECGLOBAL}/getsigensmeanp.x ${datapath}/${analdate}/ sanl_${analdate}_ensmean sanl_${analdate} ${nanals}  &
endif
wait

# clean up un-needed files.
set fh=`expr $FHMAX_save \+ $FHOUT`
while ($fh <= $FHMAX)
   set charhr="fhr`printf %02i $fh`"
   /bin/rm -f ${datapathp1}/sf*_${analdatep1}_${charhr}_mem*
   /bin/rm -f ${datapathp1}/bf*_${analdatep1}_${charhr}_mem*
   @ fh = $fh + $FHOUT
end

ls -l ${datapathp1}/sfg_${analdatep1}*mem001
ls -l ${datapathp1}/bfg_${analdatep1}*mem001
ls -l ${datapathp1}/sflxgrb_${analdatep1}*mem001
ls -l ${datapath2}/sanl*mem001
ls -l ${datapath2}/sfcanl*mem001

setenv OMP_NUM_THREADS 1

#echo "postprocessing..."
#if ($POSTPROC == 'YES') then
#   set nmem=1
#   while ($nmem <= $ENS_NUM)
#      set charnanal="mem`printf %03i $nmem`"
#      setenv DATA ${datapath2}/postgp_${charnanal}
#      mkdir $DATA
#      sh $POSTGPSH ${datapath2}/sanl_${analdate}_${charnanal} /dev/null /dev/null ${datapath2}/pgrbanl_${analdate}_${charnanal} /dev/null $IO $JO &
#      @ nmem = $nmem + 1
#   end
#   wait
#   /bin/rm -rf ${datapath2}/postgp*
#   set nmem=1
#   while ($nmem <= $ENS_NUM)
#      set charnanal="mem`printf %03i $nmem`"
#      setenv DATA ${datapath2}/postgp_${charnanal}
#      mkdir $DATA
#      sh $POSTGPSH ${datapathp1}/sfg_${analdatep1}_fhr06_${charnanal} ${datapathp1}/sflxgrb_${analdatep1}_fhr06_${charnanal} /dev/null ${datapathp1}/pgrbfg_${analdatep1}_fhr06_${charnanal} /dev/null $IO $JO &
#      @ nmem = $nmem + 1
#    end
#    wait
#    /bin/rm -rf ${datapath2}/postgp*
#endif
set FHMAX=$FHMAX_save

echo "all done `date`"

# check to see all files created
echo "checking output files .."`date`

set nanal=1
set filecheck=0
set anyfilemissing='no'
while ($nanal <= $nanals)
    set charnanal="mem`printf %03i $nanal`"
    set fhr=$FHMIN
    set outfiles=""
    while ($fhr <= $FHMAX)
       set charhr="fhr`printf %02i $fhr`"
       #set outfiles = "${outfiles} ${datapathp1}/sfg_${analdatep1}_${charhr}_${charnanal} ${datapathp1}/bfg_${analdatep1}_${charhr}_${charnanal}"
       set outfiles = "${outfiles} ${datapathp1}/sfg_${analdatep1}_${charhr}_${charnanal}"
       @ fhr = $fhr + $FHOUT
    end
    set filemissing='no'
    foreach outfile ($outfiles) 
      #ls -l $outfile
      set sz=`du -k $outfile | cut -f1`
      #${EXECGLOBAL}/chksig.x $outfile >& /dev/null
      #set filecheck=$status
      if ( ! -s $outfile || $sz < 10 || $filecheck != 0) then 
        echo "${outfile} is missing or corrupted"
        set filemissing='yes'
        set anyfilemissing='yes'
      else
        echo "${outfile} is OK"
      endif
    end
    @ nanal = $nanal + 1
end

if ($anyfilemissing == 'yes') then
    echo "there are output files missing!"
    exit 1
endif

echo "running getsigensmeanp `date`"
set fhr=$FHMIN
while ($fhr <= $FHMAX)
   set charhr="fhr`printf %02i $fhr`"
   aprun -n $nanals -N $corespernode ${EXECGLOBAL}/getsigensmeanp.x ${datapath}/${analdatep1}/ sfg_${analdatep1}_${charhr}_ensmean sfg_${analdatep1}_${charhr} ${nanals} 
   if ($status != 0) exit 1
   if ( ! -s ${datapathp1}/sfg_${analdatep1}_${charhr}_ensmean ) exit 1
   @ fhr = $fhr + $FHOUT
end
echo "done running getsigensmeanp `date`"


#echo "running chksig `date`"
#set fhr=$FHMIN
#while ($fhr <= $FHMAX)
#   set charhr="fhr`printf %02i $fhr`"
#   aprun -n $nanals -N $enkf_taskspernode ${EXECGLOBAL}/chksigp.x ${datapath}/${analdatep1}/ sfg_${analdatep1}_${charhr}  
#   if ($status != 0) set anyfilemissing='yes'
#   @ fhr = $fhr + $FHOUT
#end
#echo "done running chksig `date`"
#
#if ($anyfilemissing == 'yes') then
#    echo "there are output files missing!"
#    exit 1
#endif

set nanal=1
set filecheck=0
while ($nanal <= $nanals)
    set charnanal="mem`printf %03i $nanal`"
    set fhr=$FHMIN
    set outfiles=""
    while ($fhr <= $FHMAX)
       set charhr="fhr`printf %02i $fhr`"
       set outfiles = "${outfiles} ${datapathp1}/bfg_${analdatep1}_${charhr}_${charnanal}"
       @ fhr = $fhr + $FHOUT
    end
    set filemissing='no'
    foreach outfile ($outfiles) 
      #ls -l $outfile
      set sz=`du -k $outfile | cut -f1`
      #${EXECGLOBAL}/chksfc.x $outfile >& /dev/null
      #set filecheck=$status
      if ( ! -s $outfile || $sz < 10 || $filecheck != 0) then 
        echo "${outfile} is missing or corrupted"
        set filemissing='yes'
        set anyfilemissing='yes'
      else
        echo "${outfile} is OK"
      endif
    end
    @ nanal = $nanal + 1
end

echo "running getsfcensmeanp `date`"
set fhr=$FHMIN
while ($fhr <= $FHMAX)
   set charhr="fhr`printf %02i $fhr`"
   aprun -n $nanals -N $corespernode ${EXECGLOBAL}/getsfcensmeanp.x ${datapath}/${analdatep1}/ bfg_${analdatep1}_${charhr}_ensmean bfg_${analdatep1}_${charhr} ${nanals} 
   if ($status != 0) exit 1
   if ( ! -s ${datapathp1}/bfg_${analdatep1}_${charhr}_ensmean ) exit 1
   @ fhr = $fhr + $FHOUT
end
echo "done running getsfcensmeanp `date`"

#if ($anyfilemissing == 'yes') then
#    echo "there are output files missing!"
#    exit 1
#endif
#
#echo "running chksfc `date`"
#set fhr=$FHMIN
#while ($fhr <= $FHMAX)
#   set charhr="fhr`printf %02i $fhr`"
#   aprun -n $nanals -N $enkf_taskspernode ${EXECGLOBAL}/chksfcp.x ${datapath}/${analdatep1}/ bfg_${analdatep1}_${charhr}  
#   if ($status != 0) set anyfilemissing='yes'
#   @ fhr = $fhr + $FHOUT
#end
#echo "done running chksfc `date`"

if ($anyfilemissing == 'yes') then
    echo "there are output files missing!"
    exit 1
else
    echo "all output files seem OK"
    # clean up
    set nmem=1
    while ($nmem <= $ENS_NUM)
     set mn=`printf %02i $nmem`
     /bin/rm -f ${SIGI}_${mn}
     /bin/rm -f ${SFCI}_${mn}
     @ nmem = $nmem + 1
    end
    /bin/rm -f $SIGI
    /bin/rm -f $SFCI
    date
    exit 0
endif
